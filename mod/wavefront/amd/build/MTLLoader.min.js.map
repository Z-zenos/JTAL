{"version":3,"file":"MTLLoader.min.js","sources":["../src/MTLLoader.js"],"sourcesContent":["import {\n    Color,\n    DefaultLoadingManager,\n    FileLoader,\n    FrontSide,\n    Loader,\n    LoaderUtils,\n    MeshPhongMaterial,\n    RepeatWrapping,\n    TextureLoader,\n    Vector2,\n    sRGBEncoding\n} from 'mod_wavefront/three';\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nclass MTLLoader extends Loader {\n\n    constructor( manager )\n    {\n\n        super(manager);\n\n    }\n\n    /**\n     * Loads and parses a MTL asset from a URL.\n     *\n     * @param {String} url - URL to the MTL file.\n     * @param {Function} [onLoad] - Callback invoked with the loaded object.\n     * @param {Function} [onProgress] - Callback for download progress.\n     * @param {Function} [onError] - Callback for download errors.\n     *\n     * @see setPath setResourcePath\n     *\n     * @note In order for relative texture references to resolve correctly\n     * you must call setResourcePath() explicitly prior to load.\n     */\n    load( url, onLoad, onProgress, onError )\n    {\n\n        const scope = this;\n\n        const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase(url) : this.path;\n\n        const loader = new FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(\n            url, function ( text ) {\n\n                try {\n\n                    onLoad(scope.parse(text, path));\n\n                } catch ( e ) {\n\n                    if (onError ) {\n\n                        onError(e);\n\n                    } else {\n\n                        console.error(e);\n\n                    }\n\n                    scope.manager.itemError(url);\n\n                }\n\n            }, onProgress, onError \n        );\n\n    }\n\n    setMaterialOptions( value )\n    {\n\n        this.materialOptions = value;\n        return this;\n\n    }\n\n    /**\n     * Parses a MTL file.\n     *\n     * @param  {String} text - Content of MTL file\n     * @return {MaterialCreator}\n     *\n     * @see setPath setResourcePath\n     *\n     * @note In order for relative texture references to resolve correctly\n     * you must call setResourcePath() explicitly prior to parse.\n     */\n    parse( text, path )\n    {\n\n        const lines = text.split('\\n');\n        let info = {};\n        const delimiter_pattern = /\\s+/;\n        const materialsInfo = {};\n\n        for ( let i = 0; i < lines.length; i ++ ) {\n\n            let line = lines[ i ];\n            line = line.trim();\n\n            if (line.length === 0 || line.charAt(0) === '#' ) {\n\n                // Blank line or comment ignore\n                continue;\n\n            }\n\n            const pos = line.indexOf(' ');\n\n            let key = ( pos >= 0 ) ? line.substring(0, pos) : line;\n            key = key.toLowerCase();\n\n            let value = ( pos >= 0 ) ? line.substring(pos + 1) : '';\n            value = value.trim();\n\n            if (key === 'newmtl' ) {\n\n                // New material\n\n                info = { name: value };\n                materialsInfo[ value ] = info;\n\n            } else {\n\n                if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {\n\n                    const ss = value.split(delimiter_pattern, 3);\n                    info[ key ] = [ parseFloat(ss[ 0 ]), parseFloat(ss[ 1 ]), parseFloat(ss[ 2 ]) ];\n\n                } else {\n\n                    info[ key ] = value;\n\n                }\n\n            }\n\n        }\n\n        const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n        materialCreator.setCrossOrigin(this.crossOrigin);\n        materialCreator.setManager(this.manager);\n        materialCreator.setMaterials(materialsInfo);\n        return materialCreator;\n\n    }\n\n}\n\n/**\n * Create a new MTLLoader.MaterialCreator\n *\n * @param       baseUrl - Url relative to which textures are loaded\n * @param       options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nclass MaterialCreator {\n\n    constructor( baseUrl = '', options = {} )\n    {\n\n        this.baseUrl = baseUrl;\n        this.options = options;\n        this.materialsInfo = {};\n        this.materials = {};\n        this.materialsArray = [];\n        this.nameLookup = {};\n\n        this.crossOrigin = 'anonymous';\n\n        this.side = ( this.options.side !== undefined ) ? this.options.side : FrontSide;\n        this.wrap = ( this.options.wrap !== undefined ) ? this.options.wrap : RepeatWrapping;\n\n    }\n\n    setCrossOrigin( value )\n    {\n\n        this.crossOrigin = value;\n        return this;\n\n    }\n\n    setManager( value )\n    {\n\n        this.manager = value;\n\n    }\n\n    setMaterials( materialsInfo )\n    {\n\n        this.materialsInfo = this.convert(materialsInfo);\n        this.materials = {};\n        this.materialsArray = [];\n        this.nameLookup = {};\n\n    }\n\n    convert( materialsInfo )\n    {\n\n        if (! this.options ) { return materialsInfo;\n        }\n\n        const converted = {};\n\n        for ( const mn in materialsInfo ) {\n\n            // Convert materials info into normalized form based on options\n\n            const mat = materialsInfo[ mn ];\n\n            const covmat = {};\n\n            converted[ mn ] = covmat;\n\n            for ( const prop in mat ) {\n\n                let save = true;\n                let value = mat[ prop ];\n                const lprop = prop.toLowerCase();\n\n                switch ( lprop ) {\n\n                case 'kd':\n                case 'ka':\n                case 'ks':\n\n                    // Diffuse color (color under white light) using RGB values\n\n                    if (this.options && this.options.normalizeRGB ) {\n\n                              value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n                    }\n\n                    if (this.options && this.options.ignoreZeroRGBs ) {\n\n                        if (value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\n\n                            // ignore\n\n                            save = false;\n\n                        }\n\n                    }\n\n                  break;\n\n                default:\n\n                  break;\n\n                }\n\n                if (save ) {\n\n                    covmat[ lprop ] = value;\n\n                }\n\n            }\n\n        }\n\n        return converted;\n\n    }\n\n    preload()\n    {\n\n        for ( const mn in this.materialsInfo ) {\n\n            this.create(mn);\n\n        }\n\n    }\n\n    getIndex( materialName )\n    {\n\n        return this.nameLookup[ materialName ];\n\n    }\n\n    getAsArray()\n    {\n\n        let index = 0;\n\n        for ( const mn in this.materialsInfo ) {\n\n            this.materialsArray[ index ] = this.create(mn);\n            this.nameLookup[ mn ] = index;\n            index ++;\n\n        }\n\n        return this.materialsArray;\n\n    }\n\n    create( materialName )\n    {\n\n        if (this.materials[ materialName ] === undefined ) {\n\n            this.createMaterial_(materialName);\n\n        }\n\n        return this.materials[ materialName ];\n\n    }\n\n    createMaterial_( materialName )\n    {\n\n        // Create material\n\n        const scope = this;\n        const mat = this.materialsInfo[ materialName ];\n        const params = {\n\n            name: materialName,\n            side: this.side\n\n        };\n\n        function resolveURL( baseUrl, url )\n        {\n\n            if (typeof url !== 'string' || url === '' ) {\n                return '';\n            }\n\n            // Absolute URL\n            if (/^https?:\\/\\//i.test(url) ) { return url;\n            }\n\n            return baseUrl + url;\n\n        }\n\n        function setMapForType( mapType, value )\n        {\n\n            if (params[ mapType ] ) { return; // Keep the first encountered texture\n            }\n\n            const texParams = scope.getTextureParams(value, params);\n            const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n\n            map.repeat.copy(texParams.scale);\n            map.offset.copy(texParams.offset);\n\n            map.wrapS = scope.wrap;\n            map.wrapT = scope.wrap;\n\n            if (mapType === 'map' || mapType === 'emissiveMap' ) {\n\n                map.encoding = sRGBEncoding;\n\n            }\n\n            params[ mapType ] = map;\n\n        }\n\n        for ( const prop in mat ) {\n\n            const value = mat[ prop ];\n            let n;\n\n            if (value === '' ) { continue;\n            }\n\n            switch ( prop.toLowerCase() ) {\n\n             // Ns is material specular exponent\n\n            case 'kd':\n\n                // Diffuse color (color under white light) using RGB values\n\n                params.color = new Color().fromArray(value).convertSRGBToLinear();\n\n              break;\n\n            case 'ks':\n\n                // Specular color (color when light is reflected from shiny surface) using RGB values\n                params.specular = new Color().fromArray(value).convertSRGBToLinear();\n\n              break;\n\n            case 'ke':\n\n                // Emissive using RGB values\n                params.emissive = new Color().fromArray(value).convertSRGBToLinear();\n\n              break;\n\n            case 'map_kd':\n\n                // Diffuse texture map\n\n                setMapForType('map', value);\n\n              break;\n\n            case 'map_ks':\n\n                // Specular map\n\n                setMapForType('specularMap', value);\n\n              break;\n\n            case 'map_ke':\n\n                // Emissive map\n\n                setMapForType('emissiveMap', value);\n\n              break;\n\n            case 'norm':\n\n                setMapForType('normalMap', value);\n\n              break;\n\n            case 'map_bump':\n            case 'bump':\n\n                // Bump texture map\n\n                setMapForType('bumpMap', value);\n\n              break;\n\n            case 'map_d':\n\n                // Alpha map\n\n                setMapForType('alphaMap', value);\n                params.transparent = true;\n\n              break;\n\n            case 'ns':\n\n                // The specular exponent (defines the focus of the specular highlight)\n                // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n                params.shininess = parseFloat(value);\n\n              break;\n\n            case 'd':\n                n = parseFloat(value);\n\n                if (n < 1 ) {\n\n                    params.opacity = n;\n                    params.transparent = true;\n\n                }\n\n              break;\n\n            case 'tr':\n                n = parseFloat(value);\n\n                if (this.options && this.options.invertTrProperty ) { n = 1 - n;\n                }\n\n                if (n > 0 ) {\n\n                    params.opacity = 1 - n;\n                    params.transparent = true;\n\n                }\n\n              break;\n\n            default:\n              break;\n\n            }\n\n        }\n\n        this.materials[ materialName ] = new MeshPhongMaterial(params);\n        return this.materials[ materialName ];\n\n    }\n\n    getTextureParams( value, matParams )\n    {\n\n        const texParams = {\n\n            scale: new Vector2(1, 1),\n            offset: new Vector2(0, 0)\n\n        };\n\n        const items = value.split(/\\s+/);\n        let pos;\n\n        pos = items.indexOf('-bm');\n\n        if (pos >= 0 ) {\n\n            matParams.bumpScale = parseFloat(items[ pos + 1 ]);\n            items.splice(pos, 2);\n\n        }\n\n        pos = items.indexOf('-s');\n\n        if (pos >= 0 ) {\n\n            texParams.scale.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n            items.splice(pos, 4); // we expect 3 parameters here!\n\n        }\n\n        pos = items.indexOf('-o');\n\n        if (pos >= 0 ) {\n\n            texParams.offset.set(parseFloat(items[ pos + 1 ]), parseFloat(items[ pos + 2 ]));\n            items.splice(pos, 4); // we expect 3 parameters here!\n\n        }\n\n        texParams.url = items.join(' ').trim();\n        return texParams;\n\n    }\n\n    loadTexture( url, mapping, onLoad, onProgress, onError )\n    {\n\n        const manager = ( this.manager !== undefined ) ? this.manager : DefaultLoadingManager;\n        let loader = manager.getHandler(url);\n\n        if (loader === null ) {\n\n            loader = new TextureLoader(manager);\n\n        }\n\n        if (loader.setCrossOrigin ) { loader.setCrossOrigin(this.crossOrigin);\n        }\n\n        const texture = loader.load(url, onLoad, onProgress, onError);\n\n        if (mapping !== undefined ) { texture.mapping = mapping;\n        }\n\n        return texture;\n\n    }\n\n}\n\nexport { MTLLoader };\n"],"names":["MTLLoader","Loader","constructor","manager","load","url","onLoad","onProgress","onError","scope","this","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterialOptions","value","materialOptions","lines","split","info","delimiter_pattern","materialsInfo","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","name","ss","parseFloat","materialCreator","MaterialCreator","resourcePath","setCrossOrigin","crossOrigin","setManager","setMaterials","baseUrl","options","materials","materialsArray","nameLookup","side","undefined","FrontSide","wrap","RepeatWrapping","convert","converted","mn","mat","covmat","prop","save","lprop","normalizeRGB","ignoreZeroRGBs","preload","create","getIndex","materialName","getAsArray","index","createMaterial_","params","setMapForType","mapType","texParams","getTextureParams","map","loadTexture","test","repeat","copy","scale","offset","wrapS","wrapT","encoding","sRGBEncoding","n","color","Color","fromArray","convertSRGBToLinear","specular","emissive","transparent","shininess","opacity","invertTrProperty","MeshPhongMaterial","matParams","Vector2","items","bumpScale","splice","set","join","mapping","DefaultLoadingManager","getHandler","TextureLoader","texture"],"mappings":"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"}