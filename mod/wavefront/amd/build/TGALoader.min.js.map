{"version":3,"file":"TGALoader.min.js","sources":["../src/TGALoader.js"],"sourcesContent":["import {\n    DataTextureLoader,\n    LinearMipmapLinearFilter\n} from 'mod_wavefront/three';\n\nclass TGALoader extends DataTextureLoader {\n\n    constructor( manager )\n    {\n\n        super(manager);\n\n    }\n\n    parse( buffer )\n    {\n\n        // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n        function tgaCheckHeader( header )\n        {\n\n            switch ( header.image_type ) {\n\n             // check indexed type\n\n            case TGA_TYPE_INDEXED:\n            case TGA_TYPE_RLE_INDEXED:\n                if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n                        console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n\n                }\n\n                 break;\n\n              // check colormap type\n\n            case TGA_TYPE_RGB:\n            case TGA_TYPE_GREY:\n            case TGA_TYPE_RLE_RGB:\n            case TGA_TYPE_RLE_GREY:\n                if (header.colormap_type ) {\n\n                    console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n\n                }\n\n                 break;\n\n                    // What the need of a file without data ?\n\n            case TGA_TYPE_NO_DATA:\n                   console.error('THREE.TGALoader: No data.');\n\n                   // Invalid type ?\n\n            default:\n                   console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n\n            }\n\n            // check image width and height\n\n            if (header.width <= 0 || header.height <= 0 ) {\n\n                console.error('THREE.TGALoader: Invalid image size.');\n\n            }\n\n            // check image pixel size\n\n            if (header.pixel_size !== 8 && header.pixel_size !== 16 \n                && header.pixel_size !== 24 && header.pixel_size !== 32 \n            ) {\n\n                console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n\n            }\n\n        }\n\n        // parse tga image buffer\n\n        function tgaParse( use_rle, use_pal, header, offset, data )\n        {\n\n            let pixel_data,\n            palettes;\n\n            const pixel_size = header.pixel_size >> 3;\n            const pixel_total = header.width * header.height * pixel_size;\n\n            // read palettes\n\n            if (use_pal ) {\n\n                palettes = data.subarray(offset, offset += header.colormap_length * ( header.colormap_size >> 3 ));\n\n            }\n\n            // read RLE\n\n            if (use_rle ) {\n\n                pixel_data = new Uint8Array(pixel_total);\n\n                let c, count, i;\n                let shift = 0;\n                const pixels = new Uint8Array(pixel_size);\n\n                while ( shift < pixel_total ) {\n\n                    c = data[ offset ++ ];\n                    count = ( c & 0x7f ) + 1;\n\n                    // RLE pixels\n\n                    if (c & 0x80 ) {\n\n                         // bind pixel tmp array\n\n                        for ( i = 0; i < pixel_size; ++ i ) {\n\n                              pixels[ i ] = data[ offset ++ ];\n\n                        }\n\n                        // copy pixel array\n\n                        for ( i = 0; i < count; ++ i ) {\n\n                            pixel_data.set(pixels, shift + i * pixel_size);\n\n                        }\n\n                        shift += pixel_size * count;\n\n                    } else {\n\n                        // raw pixels\n\n                        count *= pixel_size;\n\n                        for ( i = 0; i < count; ++ i ) {\n\n                            pixel_data[ shift + i ] = data[ offset ++ ];\n\n                        }\n\n                        shift += count;\n\n                    }\n\n                }\n\n            } else {\n\n                // raw pixels\n\n                pixel_data = data.subarray(\n                    offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n                );\n\n            }\n\n             return {\n                    pixel_data: pixel_data,\n                    palettes: palettes\n            };\n\n        }\n\n        function tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes )\n        {\n\n            const colormap = palettes;\n            let color, i = 0, x, y;\n            const width = header.width;\n\n            for ( y = y_start; y !== y_end; y += y_step ) {\n\n                for ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n                    color = image[ i ];\n                    imageData[ ( x + width * y ) * 4 + 3 ] = 255;\n                    imageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n                    imageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n                    imageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n                }\n\n            }\n\n            return imageData;\n\n        }\n\n        function tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image )\n        {\n\n            let color, i = 0, x, y;\n            const width = header.width;\n\n            for ( y = y_start; y !== y_end; y += y_step ) {\n\n                for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n                    color = image[ i + 0 ] + ( image[ i + 1 ] << 8 );\n                    imageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n                    imageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n                    imageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) << 3;\n                    imageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n                }\n\n            }\n\n            return imageData;\n\n        }\n\n        function tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image )\n        {\n\n            let i = 0, x, y;\n            const width = header.width;\n\n            for ( y = y_start; y !== y_end; y += y_step ) {\n\n                for ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n                    imageData[ ( x + width * y ) * 4 + 3 ] = 255;\n                    imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n                    imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n                    imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n                }\n\n            }\n\n            return imageData;\n\n        }\n\n        function tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image )\n        {\n\n            let i = 0, x, y;\n            const width = header.width;\n\n            for ( y = y_start; y !== y_end; y += y_step ) {\n\n                for ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n                    imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n                    imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n                    imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n                    imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n                }\n\n            }\n\n            return imageData;\n\n        }\n\n        function tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image )\n        {\n\n            let color, i = 0, x, y;\n            const width = header.width;\n\n            for ( y = y_start; y !== y_end; y += y_step ) {\n\n                for ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n                    color = image[ i ];\n                    imageData[ ( x + width * y ) * 4 + 0 ] = color;\n                    imageData[ ( x + width * y ) * 4 + 1 ] = color;\n                    imageData[ ( x + width * y ) * 4 + 2 ] = color;\n                    imageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n                }\n\n            }\n\n            return imageData;\n\n        }\n\n        function tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image )\n        {\n\n            let i = 0, x, y;\n            const width = header.width;\n\n            for ( y = y_start; y !== y_end; y += y_step ) {\n\n                for ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n                    imageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n                    imageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n                    imageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n                    imageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n                }\n\n            }\n\n            return imageData;\n\n        }\n\n        function getTgaRGBA( data, width, height, image, palette )\n        {\n\n            let x_start,\n            y_start,\n            x_step,\n            y_step,\n            x_end,\n            y_end;\n\n            switch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n            default:\n            case TGA_ORIGIN_UL:\n                x_start = 0;\n                x_step = 1;\n                x_end = width;\n                y_start = 0;\n                y_step = 1;\n                y_end = height;\n              break;\n\n            case TGA_ORIGIN_BL:\n                x_start = 0;\n                x_step = 1;\n                x_end = width;\n                y_start = height - 1;\n                y_step = - 1;\n                y_end = - 1;\n              break;\n\n            case TGA_ORIGIN_UR:\n                x_start = width - 1;\n                x_step = - 1;\n                x_end = - 1;\n                y_start = 0;\n                y_step = 1;\n                y_end = height;\n              break;\n\n            case TGA_ORIGIN_BR:\n                x_start = width - 1;\n                x_step = - 1;\n                x_end = - 1;\n                y_start = height - 1;\n                y_step = - 1;\n                y_end = - 1;\n              break;\n\n            }\n\n            if (use_grey ) {\n\n                switch ( header.pixel_size ) {\n\n                case 8:\n                    tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                  break;\n\n                case 16:\n                    tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                  break;\n\n                default:\n                    console.error('THREE.TGALoader: Format not supported.');\n                  break;\n\n                }\n\n            } else {\n\n                switch ( header.pixel_size ) {\n\n                case 8:\n                    tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n                  break;\n\n                case 16:\n                    tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                  break;\n\n                case 24:\n                    tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                  break;\n\n                case 32:\n                    tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n                  break;\n\n                default:\n                    console.error('THREE.TGALoader: Format not supported.');\n                  break;\n\n                }\n\n            }\n\n            // Load image data according to specific method\n            // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n            // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n            return data;\n\n        }\n\n        // TGA constants\n\n        const TGA_TYPE_NO_DATA = 0,\n        TGA_TYPE_INDEXED = 1,\n        TGA_TYPE_RGB = 2,\n        TGA_TYPE_GREY = 3,\n        TGA_TYPE_RLE_INDEXED = 9,\n        TGA_TYPE_RLE_RGB = 10,\n        TGA_TYPE_RLE_GREY = 11,\n\n        TGA_ORIGIN_MASK = 0x30,\n        TGA_ORIGIN_SHIFT = 0x04,\n        TGA_ORIGIN_BL = 0x00,\n        TGA_ORIGIN_BR = 0x01,\n        TGA_ORIGIN_UL = 0x02,\n        TGA_ORIGIN_UR = 0x03;\n\n        if (buffer.length < 19 ) { console.error('THREE.TGALoader: Not enough data to contain header.');\n        }\n\n        let offset = 0;\n\n        const content = new Uint8Array(buffer),\n        header = {\n            id_length: content[ offset ++ ],\n            colormap_type: content[ offset ++ ],\n            image_type: content[ offset ++ ],\n            colormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n            colormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n            colormap_size: content[ offset ++ ],\n            origin: [\n            content[ offset ++ ] | content[ offset ++ ] << 8,\n            content[ offset ++ ] | content[ offset ++ ] << 8\n            ],\n            width: content[ offset ++ ] | content[ offset ++ ] << 8,\n            height: content[ offset ++ ] | content[ offset ++ ] << 8,\n            pixel_size: content[ offset ++ ],\n            flags: content[ offset ++ ]\n        };\n\n        // check tga if it is valid format\n\n        tgaCheckHeader(header);\n\n        if (header.id_length + offset > buffer.length ) {\n\n            console.error('THREE.TGALoader: No data.');\n\n        }\n\n        // skip the needn't data\n\n        offset += header.id_length;\n\n        // get targa information about RLE compression and palette\n\n        let use_rle = false,\n        use_pal = false,\n        use_grey = false;\n\n        switch ( header.image_type ) {\n\n        case TGA_TYPE_RLE_INDEXED:\n            use_rle = true;\n            use_pal = true;\n          break;\n\n        case TGA_TYPE_INDEXED:\n            use_pal = true;\n          break;\n\n        case TGA_TYPE_RLE_RGB:\n            use_rle = true;\n          break;\n\n        case TGA_TYPE_RGB:\n          break;\n\n        case TGA_TYPE_RLE_GREY:\n            use_rle = true;\n            use_grey = true;\n          break;\n\n        case TGA_TYPE_GREY:\n            use_grey = true;\n          break;\n\n        }\n\n        //\n\n        const imageData = new Uint8Array(header.width * header.height * 4);\n        const result = tgaParse(use_rle, use_pal, header, offset, content);\n        getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n\n        return {\n\n            data: imageData,\n            width: header.width,\n            height: header.height,\n            flipY: true,\n            generateMipmaps: true,\n            minFilter: LinearMipmapLinearFilter,\n\n        };\n\n    }\n\n}\n\nexport { TGALoader };\n"],"names":["TGALoader","DataTextureLoader","constructor","manager","parse","buffer","TGA_TYPE_NO_DATA","TGA_TYPE_INDEXED","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_INDEXED","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_BL","TGA_ORIGIN_BR","TGA_ORIGIN_UL","TGA_ORIGIN_UR","length","console","error","offset","content","Uint8Array","header","id_length","colormap_type","image_type","colormap_index","colormap_length","colormap_size","origin","width","height","pixel_size","flags","tgaCheckHeader","use_rle","use_pal","use_grey","imageData","result","data","pixel_data","palettes","pixel_total","subarray","c","count","i","shift","pixels","set","tgaParse","image","palette","x_start","y_start","x_step","y_step","x_end","y_end","color","x","y","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","colormap","tgaGetImageData8bits","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","getTgaRGBA","flipY","generateMipmaps","minFilter","LinearMipmapLinearFilter"],"mappings":"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"}