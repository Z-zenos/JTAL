define("mod_wavefront/ColladaLoader",["exports","mod_wavefront/three","mod_wavefront/TGALoader"],(function(_exports,_three,_TGALoader){Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.ColladaLoader=void 0;class ColladaLoader extends _three.Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,path=""===scope.path?_three.LoaderUtils.extractUrlBase(url):scope.path,loader=new _three.FileLoader(scope.manager);loader.setPath(scope.path),loader.setRequestHeader(scope.requestHeader),loader.setWithCredentials(scope.withCredentials),loader.load(url,(function(text){try{onLoad(scope.parse(text,path))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}}),onProgress,onError)}parse(text,path){function getElementsByTagName(xml,name){const array=[],childNodes=xml.childNodes;for(let i=0,l=childNodes.length;i<l;i++){const child=childNodes[i];child.nodeName===name&&array.push(child)}return array}function parseStrings(text){if(0===text.length)return[];const parts=text.trim().split(/\s+/),array=new Array(parts.length);for(let i=0,l=parts.length;i<l;i++)array[i]=parts[i];return array}function parseFloats(text){if(0===text.length)return[];const parts=text.trim().split(/\s+/),array=new Array(parts.length);for(let i=0,l=parts.length;i<l;i++)array[i]=parseFloat(parts[i]);return array}function parseInts(text){if(0===text.length)return[];const parts=text.trim().split(/\s+/),array=new Array(parts.length);for(let i=0,l=parts.length;i<l;i++)array[i]=parseInt(parts[i]);return array}function parseId(text){return text.substring(1)}function isEmpty(object){return 0===Object.keys(object).length}function parseAssetUnit(xml){return void 0!==xml&&!0===xml.hasAttribute("meter")?parseFloat(xml.getAttribute("meter")):1}function parseAssetUpAxis(xml){return void 0!==xml?xml.textContent:"Y_UP"}function parseLibrary(xml,libraryName,nodeName,parser){const library=getElementsByTagName(xml,libraryName)[0];if(void 0!==library){const elements=getElementsByTagName(library,nodeName);for(let i=0;i<elements.length;i++)parser(elements[i])}}function buildLibrary(data,builder){for(const name in data){data[name].build=builder(data[name])}}function getBuild(data,builder){return void 0!==data.build||(data.build=builder(data)),data.build}function parseAnimationSampler(xml){const data={inputs:{}};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"input"===child.nodeName){const id=parseId(child.getAttribute("source")),semantic=child.getAttribute("semantic");data.inputs[semantic]=id}}return data}function parseAnimationChannel(xml){const data={};let parts=xml.getAttribute("target").split("/");const id=parts.shift();let sid=parts.shift();const arraySyntax=-1!==sid.indexOf("("),memberSyntax=-1!==sid.indexOf(".");if(memberSyntax)parts=sid.split("."),sid=parts.shift(),data.member=parts.shift();else if(arraySyntax){const indices=sid.split("(");sid=indices.shift();for(let i=0;i<indices.length;i++)indices[i]=parseInt(indices[i].replace(/\)/,""));data.indices=indices}return data.id=id,data.sid=sid,data.arraySyntax=arraySyntax,data.memberSyntax=memberSyntax,data.sampler=parseId(xml.getAttribute("source")),data}function buildAnimation(data){const tracks=[],channels=data.channels,samplers=data.samplers,sources=data.sources;for(const target in channels)if(channels.hasOwnProperty(target)){const channel=channels[target],sampler=samplers[channel.sampler],inputId=sampler.inputs.INPUT,outputId=sampler.inputs.OUTPUT;createKeyframeTracks(buildAnimationChannel(channel,sources[inputId],sources[outputId]),tracks)}return tracks}function getAnimation(id){return getBuild(library.animations[id],buildAnimation)}function buildAnimationChannel(channel,inputSource,outputSource){const node=library.nodes[channel.id],object3D=getNode(node.id),transform=node.transforms[channel.sid],defaultMatrix=node.matrix.clone().transpose();let time,stride,i,il,j,jl;const data={};switch(transform){case"matrix":for(i=0,il=inputSource.array.length;i<il;i++)if(time=inputSource.array[i],stride=i*outputSource.stride,void 0===data[time]&&(data[time]={}),!0===channel.arraySyntax){const value=outputSource.array[stride],index=channel.indices[0]+4*channel.indices[1];data[time][index]=value}else for(j=0,jl=outputSource.stride;j<jl;j++)data[time][j]=outputSource.array[stride+j];break;case"translate":case"rotate":case"scale":console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',transform)}const keyframes=function(data,defaultMatrix){const keyframes=[];for(const time in data)keyframes.push({time:parseFloat(time),value:data[time]});keyframes.sort(ascending);for(let i=0;i<16;i++)transformAnimationData(keyframes,i,defaultMatrix.elements[i]);return keyframes;function ascending(a,b){return a.time-b.time}}(data,defaultMatrix);return{name:object3D.uuid,keyframes:keyframes}}const position=new _three.Vector3,scale=new _three.Vector3,quaternion=new _three.Quaternion;function createKeyframeTracks(animation,tracks){const keyframes=animation.keyframes,name=animation.name,times=[],positionData=[],quaternionData=[],scaleData=[];for(let i=0,l=keyframes.length;i<l;i++){const keyframe=keyframes[i],time=keyframe.time,value=keyframe.value;matrix.fromArray(value).transpose(),matrix.decompose(position,quaternion,scale),times.push(time),positionData.push(position.x,position.y,position.z),quaternionData.push(quaternion.x,quaternion.y,quaternion.z,quaternion.w),scaleData.push(scale.x,scale.y,scale.z)}return positionData.length>0&&tracks.push(new _three.VectorKeyframeTrack(name+".position",times,positionData)),quaternionData.length>0&&tracks.push(new _three.QuaternionKeyframeTrack(name+".quaternion",times,quaternionData)),scaleData.length>0&&tracks.push(new _three.VectorKeyframeTrack(name+".scale",times,scaleData)),tracks}function transformAnimationData(keyframes,property,defaultValue){let keyframe,i,l,empty=!0;for(i=0,l=keyframes.length;i<l;i++)keyframe=keyframes[i],void 0===keyframe.value[property]?keyframe.value[property]=null:empty=!1;if(!0===empty)for(i=0,l=keyframes.length;i<l;i++)keyframe=keyframes[i],keyframe.value[property]=defaultValue;else!function(keyframes,property){let prev,next;for(let i=0,l=keyframes.length;i<l;i++){const keyframe=keyframes[i];if(null===keyframe.value[property]){if(prev=getPrev(keyframes,i,property),next=getNext(keyframes,i,property),null===prev){keyframe.value[property]=next.value[property];continue}if(null===next){keyframe.value[property]=prev.value[property];continue}interpolate(keyframe,prev,next,property)}}}(keyframes,property)}function getPrev(keyframes,i,property){for(;i>=0;){const keyframe=keyframes[i];if(null!==keyframe.value[property])return keyframe;i--}return null}function getNext(keyframes,i,property){for(;i<keyframes.length;){const keyframe=keyframes[i];if(null!==keyframe.value[property])return keyframe;i++}return null}function interpolate(key,prev,next,property){next.time-prev.time!=0?key.value[property]=(key.time-prev.time)*(next.value[property]-prev.value[property])/(next.time-prev.time)+prev.value[property]:key.value[property]=prev.value[property]}function buildAnimationClip(data){const tracks=[],name=data.name,duration=data.end-data.start||-1,animations=data.animations;for(let i=0,il=animations.length;i<il;i++){const animationTracks=getAnimation(animations[i]);for(let j=0,jl=animationTracks.length;j<jl;j++)tracks.push(animationTracks[j])}return new _three.AnimationClip(name,duration,tracks)}function getAnimationClip(id){return getBuild(library.clips[id],buildAnimationClip)}function parseSkin(xml){const data={sources:{}};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"bind_shape_matrix":data.bindShapeMatrix=parseFloats(child.textContent);break;case"source":const id=child.getAttribute("id");data.sources[id]=parseSource(child);break;case"joints":data.joints=parseJoints(child);break;case"vertex_weights":data.vertexWeights=parseVertexWeights(child)}}return data}function parseJoints(xml){const data={inputs:{}};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"input"===child.nodeName){const semantic=child.getAttribute("semantic"),id=parseId(child.getAttribute("source"));data.inputs[semantic]=id}}return data}function parseVertexWeights(xml){const data={inputs:{}};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"input":const semantic=child.getAttribute("semantic"),id=parseId(child.getAttribute("source")),offset=parseInt(child.getAttribute("offset"));data.inputs[semantic]={id:id,offset:offset};break;case"vcount":data.vcount=parseInts(child.textContent);break;case"v":data.v=parseInts(child.textContent)}}return data}function buildController(data){const build={id:data.id},geometry=library.geometries[build.id];return void 0!==data.skin&&(build.skin=function(data){const BONE_LIMIT=4,build={joints:[],indices:{array:[],stride:BONE_LIMIT},weights:{array:[],stride:BONE_LIMIT}},sources=data.sources,vertexWeights=data.vertexWeights,vcount=vertexWeights.vcount,v=vertexWeights.v,jointOffset=vertexWeights.inputs.JOINT.offset,weightOffset=vertexWeights.inputs.WEIGHT.offset,jointSource=data.sources[data.joints.inputs.JOINT],inverseSource=data.sources[data.joints.inputs.INV_BIND_MATRIX],weights=sources[vertexWeights.inputs.WEIGHT.id].array;let i,j,l,stride=0;for(i=0,l=vcount.length;i<l;i++){const jointCount=vcount[i],vertexSkinData=[];for(j=0;j<jointCount;j++){const skinIndex=v[stride+jointOffset],skinWeight=weights[v[stride+weightOffset]];vertexSkinData.push({index:skinIndex,weight:skinWeight}),stride+=2}for(vertexSkinData.sort(descending),j=0;j<BONE_LIMIT;j++){const d=vertexSkinData[j];void 0!==d?(build.indices.array.push(d.index),build.weights.array.push(d.weight)):(build.indices.array.push(0),build.weights.array.push(0))}}data.bindShapeMatrix?build.bindMatrix=(new _three.Matrix4).fromArray(data.bindShapeMatrix).transpose():build.bindMatrix=(new _three.Matrix4).identity();for(i=0,l=jointSource.array.length;i<l;i++){const name=jointSource.array[i],boneInverse=(new _three.Matrix4).fromArray(inverseSource.array,i*inverseSource.stride).transpose();build.joints.push({name:name,boneInverse:boneInverse})}return build;function descending(a,b){return b.weight-a.weight}}(data.skin),geometry.sources.skinIndices=build.skin.indices,geometry.sources.skinWeights=build.skin.weights),build}function buildImage(data){return void 0!==data.build?data.build:data.init_from}function getImage(id){const data=library.images[id];return void 0!==data?getBuild(data,buildImage):(console.warn("THREE.ColladaLoader: Couldn't find image with ID:",id),null)}function parseEffectProfileCOMMON(xml){const data={surfaces:{},samplers:{}};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"newparam":parseEffectNewparam(child,data);break;case"technique":data.technique=parseEffectTechnique(child);break;case"extra":data.extra=parseEffectExtra(child)}}return data}function parseEffectNewparam(xml,data){const sid=xml.getAttribute("sid");for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"surface":data.surfaces[sid]=parseEffectSurface(child);break;case"sampler2D":data.samplers[sid]=parseEffectSampler(child)}}}function parseEffectSurface(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"init_from"===child.nodeName)data.init_from=child.textContent}return data}function parseEffectSampler(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"source"===child.nodeName)data.source=child.textContent}return data}function parseEffectTechnique(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"constant":case"lambert":case"blinn":case"phong":data.type=child.nodeName,data.parameters=parseEffectParameters(child);break;case"extra":data.extra=parseEffectExtra(child)}}return data}function parseEffectParameters(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"emission":case"diffuse":case"specular":case"bump":case"ambient":case"shininess":case"transparency":data[child.nodeName]=parseEffectParameter(child);break;case"transparent":data[child.nodeName]={opaque:child.hasAttribute("opaque")?child.getAttribute("opaque"):"A_ONE",data:parseEffectParameter(child)}}}return data}function parseEffectParameter(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"color":data[child.nodeName]=parseFloats(child.textContent);break;case"float":data[child.nodeName]=parseFloat(child.textContent);break;case"texture":data[child.nodeName]={id:child.getAttribute("texture"),extra:parseEffectParameterTexture(child)}}}return data}function parseEffectParameterTexture(xml){const data={technique:{}};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"extra"===child.nodeName)parseEffectParameterTextureExtra(child,data)}return data}function parseEffectParameterTextureExtra(xml,data){for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"technique"===child.nodeName)parseEffectParameterTextureExtraTechnique(child,data)}}function parseEffectParameterTextureExtraTechnique(xml,data){for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"repeatU":case"repeatV":case"offsetU":case"offsetV":data.technique[child.nodeName]=parseFloat(child.textContent);break;case"wrapU":case"wrapV":"TRUE"===child.textContent.toUpperCase()?data.technique[child.nodeName]=1:"FALSE"===child.textContent.toUpperCase()?data.technique[child.nodeName]=0:data.technique[child.nodeName]=parseInt(child.textContent);break;case"bump":data[child.nodeName]=parseEffectExtraTechniqueBump(child)}}}function parseEffectExtra(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"technique"===child.nodeName)data.technique=parseEffectExtraTechnique(child)}return data}function parseEffectExtraTechnique(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"double_sided":data[child.nodeName]=parseInt(child.textContent);break;case"bump":data[child.nodeName]=parseEffectExtraTechniqueBump(child)}}return data}function parseEffectExtraTechniqueBump(xml){for(var data={},i=0,l=xml.childNodes.length;i<l;i++){var child=xml.childNodes[i];if(1===child.nodeType&&"texture"===child.nodeName)data[child.nodeName]={id:child.getAttribute("texture"),texcoord:child.getAttribute("texcoord"),extra:parseEffectParameterTexture(child)}}return data}function buildEffect(data){return data}function buildMaterial(data){const effect=(id=data.url,getBuild(library.effects[id],buildEffect));var id;const technique=effect.profile.technique;let material;switch(technique.type){case"phong":case"blinn":material=new _three.MeshPhongMaterial;break;case"lambert":material=new _three.MeshLambertMaterial;break;default:material=new _three.MeshBasicMaterial}function getTexture(textureObject){const sampler=effect.profile.samplers[textureObject.id];let image=null;if(void 0!==sampler){image=getImage(effect.profile.surfaces[sampler.source].init_from)}else console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."),image=getImage(textureObject.id);if(null!==image){const loader=function(image){let loader,extension=image.slice(2+(image.lastIndexOf(".")-1>>>0));extension=extension.toLowerCase(),loader="tga"===extension?tgaLoader:textureLoader;return loader}(image);if(void 0!==loader){const texture=loader.load(image),extra=textureObject.extra;if(void 0!==extra&&void 0!==extra.technique&&!1===isEmpty(extra.technique)){const technique=extra.technique;texture.wrapS=technique.wrapU?_three.RepeatWrapping:_three.ClampToEdgeWrapping,texture.wrapT=technique.wrapV?_three.RepeatWrapping:_three.ClampToEdgeWrapping,texture.offset.set(technique.offsetU||0,technique.offsetV||0),texture.repeat.set(technique.repeatU||1,technique.repeatV||1)}else texture.wrapS=_three.RepeatWrapping,texture.wrapT=_three.RepeatWrapping;return texture}return console.warn("THREE.ColladaLoader: Loader for texture %s not found.",image),null}return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:",textureObject.id),null}material.name=data.name||"";const parameters=technique.parameters;for(const key in parameters){const parameter=parameters[key];switch(key){case"diffuse":parameter.color&&material.color.fromArray(parameter.color),parameter.texture&&(material.map=getTexture(parameter.texture));break;case"specular":parameter.color&&material.specular&&material.specular.fromArray(parameter.color),parameter.texture&&(material.specularMap=getTexture(parameter.texture));break;case"bump":parameter.texture&&(material.normalMap=getTexture(parameter.texture));break;case"ambient":parameter.texture&&(material.lightMap=getTexture(parameter.texture));break;case"shininess":parameter.float&&material.shininess&&(material.shininess=parameter.float);break;case"emission":parameter.color&&material.emissive&&material.emissive.fromArray(parameter.color),parameter.texture&&(material.emissiveMap=getTexture(parameter.texture))}}let transparent=parameters.transparent,transparency=parameters.transparency;if(void 0===transparency&&transparent&&(transparency={float:1}),void 0===transparent&&transparency&&(transparent={opaque:"A_ONE",data:{color:[1,1,1,1]}}),transparent&&transparency)if(transparent.data.texture)material.transparent=!0;else{const color=transparent.data.color;switch(transparent.opaque){case"A_ONE":material.opacity=color[3]*transparency.float;break;case"RGB_ZERO":material.opacity=1-color[0]*transparency.float;break;case"A_ZERO":material.opacity=1-color[3]*transparency.float;break;case"RGB_ONE":material.opacity=color[0]*transparency.float;break;default:console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.',transparent.opaque)}material.opacity<1&&(material.transparent=!0)}if(void 0!==technique.extra&&void 0!==technique.extra.technique){const techniques=technique.extra.technique;for(const k in techniques){const v=techniques[k];switch(k){case"double_sided":material.side=1===v?_three.DoubleSide:_three.FrontSide;break;case"bump":material.normalMap=getTexture(v.texture),material.normalScale=new _three.Vector2(1,1)}}}return material}function getMaterial(id){return getBuild(library.materials[id],buildMaterial)}function parseCameraOptics(xml){for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if("technique_common"===child.nodeName)return parseCameraTechnique(child)}return{}}function parseCameraTechnique(xml){const data={};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];switch(child.nodeName){case"perspective":case"orthographic":data.technique=child.nodeName,data.parameters=parseCameraParameters(child)}}return data}function parseCameraParameters(xml){const data={};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];switch(child.nodeName){case"xfov":case"yfov":case"xmag":case"ymag":case"znear":case"zfar":case"aspect_ratio":data[child.nodeName]=parseFloat(child.textContent)}}return data}function buildCamera(data){let camera;switch(data.optics.technique){case"perspective":camera=new _three.PerspectiveCamera(data.optics.parameters.yfov,data.optics.parameters.aspect_ratio,data.optics.parameters.znear,data.optics.parameters.zfar);break;case"orthographic":let ymag=data.optics.parameters.ymag,xmag=data.optics.parameters.xmag;const aspectRatio=data.optics.parameters.aspect_ratio;xmag=void 0===xmag?ymag*aspectRatio:xmag,ymag=void 0===ymag?xmag/aspectRatio:ymag,xmag*=.5,ymag*=.5,camera=new _three.OrthographicCamera(-xmag,xmag,ymag,-ymag,data.optics.parameters.znear,data.optics.parameters.zfar);break;default:camera=new _three.PerspectiveCamera}return camera.name=data.name||"",camera}function getCamera(id){const data=library.cameras[id];return void 0!==data?getBuild(data,buildCamera):(console.warn("THREE.ColladaLoader: Couldn't find camera with ID:",id),null)}function parseLightTechnique(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"directional":case"point":case"spot":case"ambient":data.technique=child.nodeName,data.parameters=parseLightParameters(child)}}return data}function parseLightParameters(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"color":const array=parseFloats(child.textContent);data.color=(new _three.Color).fromArray(array);break;case"falloff_angle":data.falloffAngle=parseFloat(child.textContent);break;case"quadratic_attenuation":const f=parseFloat(child.textContent);data.distance=f?Math.sqrt(1/f):0}}return data}function buildLight(data){let light;switch(data.technique){case"directional":light=new _three.DirectionalLight;break;case"point":light=new _three.PointLight;break;case"spot":light=new _three.SpotLight;break;case"ambient":light=new _three.AmbientLight}return data.parameters.color&&light.color.copy(data.parameters.color),data.parameters.distance&&(light.distance=data.parameters.distance),light}function getLight(id){const data=library.lights[id];return void 0!==data?getBuild(data,buildLight):(console.warn("THREE.ColladaLoader: Couldn't find light with ID:",id),null)}function parseSource(xml){const data={array:[],stride:3};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"float_array":data.array=parseFloats(child.textContent);break;case"Name_array":data.array=parseStrings(child.textContent);break;case"technique_common":const accessor=getElementsByTagName(child,"accessor")[0];void 0!==accessor&&(data.stride=parseInt(accessor.getAttribute("stride")))}}return data}function parseGeometryVertices(xml){const data={};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];1===child.nodeType&&(data[child.getAttribute("semantic")]=parseId(child.getAttribute("source")))}return data}function parseGeometryPrimitive(xml){const primitive={type:xml.nodeName,material:xml.getAttribute("material"),count:parseInt(xml.getAttribute("count")),inputs:{},stride:0,hasUV:!1};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"input":const id=parseId(child.getAttribute("source")),semantic=child.getAttribute("semantic"),offset=parseInt(child.getAttribute("offset")),set=parseInt(child.getAttribute("set")),inputname=set>0?semantic+set:semantic;primitive.inputs[inputname]={id:id,offset:offset},primitive.stride=Math.max(primitive.stride,offset+1),"TEXCOORD"===semantic&&(primitive.hasUV=!0);break;case"vcount":primitive.vcount=parseInts(child.textContent);break;case"p":primitive.p=parseInts(child.textContent)}}return primitive}function checkUVCoordinates(primitives){let count=0;for(let i=0,l=primitives.length;i<l;i++){!0===primitives[i].hasUV&&count++}count>0&&count<primitives.length&&(primitives.uvsNeedsFix=!0)}function buildGeometry(data){const build={},sources=data.sources,vertices=data.vertices,primitives=data.primitives;if(0===primitives.length)return{};const groupedPrimitives=function(primitives){const build={};for(let i=0;i<primitives.length;i++){const primitive=primitives[i];void 0===build[primitive.type]&&(build[primitive.type]=[]),build[primitive.type].push(primitive)}return build}(primitives);for(const type in groupedPrimitives){const primitiveType=groupedPrimitives[type];checkUVCoordinates(primitiveType),build[type]=buildGeometryType(primitiveType,sources,vertices)}return build}function buildGeometryType(primitives,sources,vertices){const build={},position={array:[],stride:0},normal={array:[],stride:0},uv={array:[],stride:0},uv2={array:[],stride:0},color={array:[],stride:0},skinIndex_array=[],skinIndex_stride=4,skinWeight_array=[],skinWeight_stride=4,geometry=new _three.BufferGeometry,materialKeys=[];let start=0;for(let p=0;p<primitives.length;p++){const primitive=primitives[p],inputs=primitive.inputs;let count=0;switch(primitive.type){case"lines":case"linestrips":count=2*primitive.count;break;case"triangles":count=3*primitive.count;break;case"polylist":for(let g=0;g<primitive.count;g++){const vc=primitive.vcount[g];switch(vc){case 3:count+=3;break;case 4:count+=6;break;default:count+=3*(vc-2)}}break;default:console.warn("THREE.ColladaLoader: Unknow primitive type:",primitive.type)}geometry.addGroup(start,count,p),start+=count,primitive.material&&materialKeys.push(primitive.material);for(const name in inputs){const input=inputs[name];switch(name){case"VERTEX":for(const key in vertices){const id=vertices[key];switch(key){case"POSITION":const prevLength=position.array.length;if(buildGeometryData(primitive,sources[id],input.offset,position.array),position.stride=sources[id].stride,sources.skinWeights&&sources.skinIndices&&(buildGeometryData(primitive,sources.skinIndices,input.offset,skinIndex_array),buildGeometryData(primitive,sources.skinWeights,input.offset,skinWeight_array)),!1===primitive.hasUV&&!0===primitives.uvsNeedsFix){const count=(position.array.length-prevLength)/position.stride;for(let i=0;i<count;i++)uv.array.push(0,0)}break;case"NORMAL":buildGeometryData(primitive,sources[id],input.offset,normal.array),normal.stride=sources[id].stride;break;case"COLOR":buildGeometryData(primitive,sources[id],input.offset,color.array),color.stride=sources[id].stride;break;case"TEXCOORD":buildGeometryData(primitive,sources[id],input.offset,uv.array),uv.stride=sources[id].stride;break;case"TEXCOORD1":buildGeometryData(primitive,sources[id],input.offset,uv2.array),uv.stride=sources[id].stride;break;default:console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.',key)}}break;case"NORMAL":buildGeometryData(primitive,sources[input.id],input.offset,normal.array),normal.stride=sources[input.id].stride;break;case"COLOR":buildGeometryData(primitive,sources[input.id],input.offset,color.array),color.stride=sources[input.id].stride;break;case"TEXCOORD":buildGeometryData(primitive,sources[input.id],input.offset,uv.array),uv.stride=sources[input.id].stride;break;case"TEXCOORD1":buildGeometryData(primitive,sources[input.id],input.offset,uv2.array),uv2.stride=sources[input.id].stride}}}return position.array.length>0&&geometry.setAttribute("position",new _three.Float32BufferAttribute(position.array,position.stride)),normal.array.length>0&&geometry.setAttribute("normal",new _three.Float32BufferAttribute(normal.array,normal.stride)),color.array.length>0&&geometry.setAttribute("color",new _three.Float32BufferAttribute(color.array,color.stride)),uv.array.length>0&&geometry.setAttribute("uv",new _three.Float32BufferAttribute(uv.array,uv.stride)),uv2.array.length>0&&geometry.setAttribute("uv2",new _three.Float32BufferAttribute(uv2.array,uv2.stride)),skinIndex_array.length>0&&geometry.setAttribute("skinIndex",new _three.Float32BufferAttribute(skinIndex_array,skinIndex_stride)),skinWeight_array.length>0&&geometry.setAttribute("skinWeight",new _three.Float32BufferAttribute(skinWeight_array,skinWeight_stride)),build.data=geometry,build.type=primitives[0].type,build.materialKeys=materialKeys,build}function buildGeometryData(primitive,source,offset,array){const indices=primitive.p,stride=primitive.stride,vcount=primitive.vcount;function pushVector(i){let index=indices[i+offset]*sourceStride;const length=index+sourceStride;for(;index<length;index++)array.push(sourceArray[index])}const sourceArray=source.array,sourceStride=source.stride;if(void 0!==primitive.vcount){let index=0;for(let i=0,l=vcount.length;i<l;i++){const count=vcount[i];if(4===count){const b=index+1*stride,c=index+2*stride,d=index+3*stride;pushVector(index+0*stride),pushVector(b),pushVector(d),pushVector(b),pushVector(c),pushVector(d)}else if(3===count){const b=index+1*stride,c=index+2*stride;pushVector(index+0*stride),pushVector(b),pushVector(c)}else if(count>4)for(let k=1,kl=count-2;k<=kl;k++){const b=index+stride*k,c=index+stride*(k+1);pushVector(index+0*stride),pushVector(b),pushVector(c)}index+=stride*count}}else for(let i=0,l=indices.length;i<l;i+=stride)pushVector(i)}function getGeometry(id){return getBuild(library.geometries[id],buildGeometry)}function buildKinematicsModel(data){return void 0!==data.build?data.build:data}function parseKinematicsTechniqueCommon(xml,data){for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"joint":data.joints[child.getAttribute("sid")]=parseKinematicsJoint(child);break;case"link":data.links.push(parseKinematicsLink(child))}}}function parseKinematicsJoint(xml){let data;for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"prismatic":case"revolute":data=parseKinematicsJointParameter(child)}}return data}function parseKinematicsJointParameter(xml){const data={sid:xml.getAttribute("sid"),name:xml.getAttribute("name")||"",axis:new _three.Vector3,limits:{min:0,max:0},type:xml.nodeName,static:!1,zeroPosition:0,middlePosition:0};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"axis":const array=parseFloats(child.textContent);data.axis.fromArray(array);break;case"limits":const max=child.getElementsByTagName("max")[0],min=child.getElementsByTagName("min")[0];data.limits.max=parseFloat(max.textContent),data.limits.min=parseFloat(min.textContent)}}return data.limits.min>=data.limits.max&&(data.static=!0),data.middlePosition=(data.limits.min+data.limits.max)/2,data}function parseKinematicsLink(xml){const data={sid:xml.getAttribute("sid"),name:xml.getAttribute("name")||"",attachments:[],transforms:[]};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"attachment_full":data.attachments.push(parseKinematicsAttachment(child));break;case"matrix":case"translate":case"rotate":data.transforms.push(parseKinematicsTransform(child))}}return data}function parseKinematicsAttachment(xml){const data={joint:xml.getAttribute("joint").split("/").pop(),transforms:[],links:[]};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"link":data.links.push(parseKinematicsLink(child));break;case"matrix":case"translate":case"rotate":data.transforms.push(parseKinematicsTransform(child))}}return data}function parseKinematicsTransform(xml){const data={type:xml.nodeName},array=parseFloats(xml.textContent);switch(data.type){case"matrix":data.obj=new _three.Matrix4,data.obj.fromArray(array).transpose();break;case"translate":data.obj=new _three.Vector3,data.obj.fromArray(array);break;case"rotate":data.obj=new _three.Vector3,data.obj.fromArray(array),data.angle=_three.MathUtils.degToRad(array[3])}return data}function parsePhysicsRigidBody(xml,data){for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"technique_common"===child.nodeName)parsePhysicsTechniqueCommon(child,data)}}function parsePhysicsTechniqueCommon(xml,data){for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"inertia":data.inertia=parseFloats(child.textContent);break;case"mass":data.mass=parseFloats(child.textContent)[0]}}}function parseKinematicsBindJointAxis(xml){const data={target:xml.getAttribute("target").split("/").pop()};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"axis"===child.nodeName){const param=child.getElementsByTagName("param")[0];data.axis=param.textContent;const tmpJointIndex=data.axis.split("inst_").pop().split("axis")[0];data.jointIndex=tmpJointIndex.substr(0,tmpJointIndex.length-1)}}return data}function buildKinematicsScene(data){return void 0!==data.build?data.build:data}function buildTransformList(node){const transforms=[],xml=collada.querySelector('[id="'+node.id+'"]');for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1!==child.nodeType)continue;let array,vector;switch(child.nodeName){case"matrix":array=parseFloats(child.textContent);const matrix=(new _three.Matrix4).fromArray(array).transpose();transforms.push({sid:child.getAttribute("sid"),type:child.nodeName,obj:matrix});break;case"translate":case"scale":array=parseFloats(child.textContent),vector=(new _three.Vector3).fromArray(array),transforms.push({sid:child.getAttribute("sid"),type:child.nodeName,obj:vector});break;case"rotate":array=parseFloats(child.textContent),vector=(new _three.Vector3).fromArray(array);const angle=_three.MathUtils.degToRad(array[3]);transforms.push({sid:child.getAttribute("sid"),type:child.nodeName,obj:vector,angle:angle})}}return transforms}const matrix=new _three.Matrix4,vector=new _three.Vector3;function parseNode(xml){const data={name:xml.getAttribute("name")||"",type:xml.getAttribute("type"),id:xml.getAttribute("id"),sid:xml.getAttribute("sid"),matrix:new _three.Matrix4,nodes:[],instanceCameras:[],instanceControllers:[],instanceLights:[],instanceGeometries:[],instanceNodes:[],transforms:{}};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1!==child.nodeType)continue;let array;switch(child.nodeName){case"node":data.nodes.push(child.getAttribute("id")),parseNode(child);break;case"instance_camera":data.instanceCameras.push(parseId(child.getAttribute("url")));break;case"instance_controller":data.instanceControllers.push(parseNodeInstance(child));break;case"instance_light":data.instanceLights.push(parseId(child.getAttribute("url")));break;case"instance_geometry":data.instanceGeometries.push(parseNodeInstance(child));break;case"instance_node":data.instanceNodes.push(parseId(child.getAttribute("url")));break;case"matrix":array=parseFloats(child.textContent),data.matrix.multiply(matrix.fromArray(array).transpose()),data.transforms[child.getAttribute("sid")]=child.nodeName;break;case"translate":array=parseFloats(child.textContent),vector.fromArray(array),data.matrix.multiply(matrix.makeTranslation(vector.x,vector.y,vector.z)),data.transforms[child.getAttribute("sid")]=child.nodeName;break;case"rotate":array=parseFloats(child.textContent);const angle=_three.MathUtils.degToRad(array[3]);data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array),angle)),data.transforms[child.getAttribute("sid")]=child.nodeName;break;case"scale":array=parseFloats(child.textContent),data.matrix.scale(vector.fromArray(array)),data.transforms[child.getAttribute("sid")]=child.nodeName;break;case"extra":break;default:console.log(child)}}return hasNode(data.id)?console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.",data.id):library.nodes[data.id]=data,data}function parseNodeInstance(xml){const data={id:parseId(xml.getAttribute("url")),materials:{},skeletons:[]};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];switch(child.nodeName){case"bind_material":const instances=child.getElementsByTagName("instance_material");for(let j=0;j<instances.length;j++){const instance=instances[j],symbol=instance.getAttribute("symbol"),target=instance.getAttribute("target");data.materials[symbol]=parseId(target)}break;case"skeleton":data.skeletons.push(parseId(child.textContent))}}return data}function buildSkeleton(skeletons,joints){const boneData=[],sortedBoneData=[];let i,j,data;for(i=0;i<skeletons.length;i++){const skeleton=skeletons[i];let root;if(hasNode(skeleton))root=getNode(skeleton),buildBoneHierarchy(root,joints,boneData);else if(id=skeleton,void 0!==library.visualScenes[id]){const children=library.visualScenes[skeleton].children;for(let j=0;j<children.length;j++){const child=children[j];if("JOINT"===child.type){buildBoneHierarchy(getNode(child.id),joints,boneData)}}}else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:",skeleton)}var id;for(i=0;i<joints.length;i++)for(j=0;j<boneData.length;j++)if(data=boneData[j],data.bone.name===joints[i].name){sortedBoneData[i]=data,data.processed=!0;break}for(i=0;i<boneData.length;i++)data=boneData[i],!1===data.processed&&(sortedBoneData.push(data),data.processed=!0);const bones=[],boneInverses=[];for(i=0;i<sortedBoneData.length;i++)data=sortedBoneData[i],bones.push(data.bone),boneInverses.push(data.boneInverse);return new _three.Skeleton(bones,boneInverses)}function buildBoneHierarchy(root,joints,boneData){root.traverse((function(object){if(!0===object.isBone){let boneInverse;for(let i=0;i<joints.length;i++){const joint=joints[i];if(joint.name===object.name){boneInverse=joint.boneInverse;break}}void 0===boneInverse&&(boneInverse=new _three.Matrix4),boneData.push({bone:object,boneInverse:boneInverse,processed:!1})}}))}function buildNode(data){const objects=[],matrix=data.matrix,nodes=data.nodes,type=data.type,instanceCameras=data.instanceCameras,instanceControllers=data.instanceControllers,instanceLights=data.instanceLights,instanceGeometries=data.instanceGeometries,instanceNodes=data.instanceNodes;for(let i=0,l=nodes.length;i<l;i++)objects.push(getNode(nodes[i]));for(let i=0,l=instanceCameras.length;i<l;i++){const instanceCamera=getCamera(instanceCameras[i]);null!==instanceCamera&&objects.push(instanceCamera.clone())}for(let i=0,l=instanceControllers.length;i<l;i++){const instance=instanceControllers[i],controller=(id=instance.id,getBuild(library.controllers[id],buildController)),newObjects=buildObjects(getGeometry(controller.id),instance.materials),skeleton=buildSkeleton(instance.skeletons,controller.skin.joints);for(let j=0,jl=newObjects.length;j<jl;j++){const object=newObjects[j];object.isSkinnedMesh&&(object.bind(skeleton,controller.skin.bindMatrix),object.normalizeSkinWeights()),objects.push(object)}}var id;for(let i=0,l=instanceLights.length;i<l;i++){const instanceLight=getLight(instanceLights[i]);null!==instanceLight&&objects.push(instanceLight.clone())}for(let i=0,l=instanceGeometries.length;i<l;i++){const instance=instanceGeometries[i],newObjects=buildObjects(getGeometry(instance.id),instance.materials);for(let j=0,jl=newObjects.length;j<jl;j++)objects.push(newObjects[j])}for(let i=0,l=instanceNodes.length;i<l;i++)objects.push(getNode(instanceNodes[i]).clone());let object;if(0===nodes.length&&1===objects.length)object=objects[0];else{object="JOINT"===type?new _three.Bone:new _three.Group;for(let i=0;i<objects.length;i++)object.add(objects[i])}return object.name="JOINT"===type?data.sid:data.name,object.matrix.copy(matrix),object.matrix.decompose(object.position,object.quaternion,object.scale),object}const fallbackMaterial=new _three.MeshBasicMaterial({color:16711935});function resolveMaterialBinding(keys,instanceMaterials){const materials=[];for(let i=0,l=keys.length;i<l;i++){const id=instanceMaterials[keys[i]];void 0===id?(console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.",keys[i]),materials.push(fallbackMaterial)):materials.push(getMaterial(id))}return materials}function buildObjects(geometries,instanceMaterials){const objects=[];for(const type in geometries){const geometry=geometries[type],materials=resolveMaterialBinding(geometry.materialKeys,instanceMaterials);0===materials.length&&("lines"===type||"linestrips"===type?materials.push(new _three.LineBasicMaterial):materials.push(new _three.MeshPhongMaterial));const skinning=void 0!==geometry.data.attributes.skinIndex,material=1===materials.length?materials[0]:materials;let object;switch(type){case"lines":object=new _three.LineSegments(geometry.data,material);break;case"linestrips":object=new _three.Line(geometry.data,material);break;case"triangles":case"polylist":object=skinning?new _three.SkinnedMesh(geometry.data,material):new _three.Mesh(geometry.data,material)}objects.push(object)}return objects}function hasNode(id){return void 0!==library.nodes[id]}function getNode(id){return getBuild(library.nodes[id],buildNode)}function buildVisualScene(data){const group=new _three.Group;group.name=data.name;const children=data.children;for(let i=0;i<children.length;i++){const child=children[i];group.add(getNode(child.id))}return group}function getVisualScene(id){return getBuild(library.visualScenes[id],buildVisualScene)}if(0===text.length)return{scene:new _three.Scene};const xml=(new DOMParser).parseFromString(text,"application/xml"),collada=getElementsByTagName(xml,"COLLADA")[0],parserError=xml.getElementsByTagName("parsererror")[0];if(void 0!==parserError){const errorElement=getElementsByTagName(parserError,"div")[0];let errorText;return errorText=errorElement?errorElement.textContent:function(parserError){let result="";const stack=[parserError];for(;stack.length;){const node=stack.shift();node.nodeType===Node.TEXT_NODE?result+=node.textContent:(result+="\n",stack.push.apply(stack,node.childNodes))}return result.trim()}(parserError),console.error("THREE.ColladaLoader: Failed to parse collada file.\n",errorText),null}const version=collada.getAttribute("version");console.log("THREE.ColladaLoader: File version",version);const asset=function(xml){return{unit:parseAssetUnit(getElementsByTagName(xml,"unit")[0]),upAxis:parseAssetUpAxis(getElementsByTagName(xml,"up_axis")[0])}}(getElementsByTagName(collada,"asset")[0]),textureLoader=new _three.TextureLoader(this.manager);let tgaLoader;textureLoader.setPath(this.resourcePath||path).setCrossOrigin(this.crossOrigin),_TGALoader.TGALoader&&(tgaLoader=new _TGALoader.TGALoader(this.manager),tgaLoader.setPath(this.resourcePath||path));const animations=[];let kinematics={},count=0;const library={animations:{},clips:{},controllers:{},images:{},effects:{},materials:{},cameras:{},lights:{},geometries:{},nodes:{},visualScenes:{},kinematicsModels:{},physicsModels:{},kinematicsScenes:{}};parseLibrary(collada,"library_animations","animation",(function parseAnimation(xml){const data={sources:{},samplers:{},channels:{}};let hasChildren=!1;for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1!==child.nodeType)continue;let id;switch(child.nodeName){case"source":id=child.getAttribute("id"),data.sources[id]=parseSource(child);break;case"sampler":id=child.getAttribute("id"),data.samplers[id]=parseAnimationSampler(child);break;case"channel":id=child.getAttribute("target"),data.channels[id]=parseAnimationChannel(child);break;case"animation":parseAnimation(child),hasChildren=!0;break;default:console.log(child)}}!1===hasChildren&&(library.animations[xml.getAttribute("id")||_three.MathUtils.generateUUID()]=data)})),parseLibrary(collada,"library_animation_clips","animation_clip",(function(xml){const data={name:xml.getAttribute("id")||"default",start:parseFloat(xml.getAttribute("start")||0),end:parseFloat(xml.getAttribute("end")||0),animations:[]};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"instance_animation"===child.nodeName)data.animations.push(parseId(child.getAttribute("url")))}library.clips[xml.getAttribute("id")]=data})),parseLibrary(collada,"library_controllers","controller",(function(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType)switch(child.nodeName){case"skin":data.id=parseId(child.getAttribute("source")),data.skin=parseSkin(child);break;case"morph":data.id=parseId(child.getAttribute("source")),console.warn("THREE.ColladaLoader: Morph target animation not supported yet.")}}library.controllers[xml.getAttribute("id")]=data})),parseLibrary(collada,"library_images","image",(function(xml){const data={init_from:getElementsByTagName(xml,"init_from")[0].textContent};library.images[xml.getAttribute("id")]=data})),parseLibrary(collada,"library_effects","effect",(function(xml){const data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"profile_COMMON"===child.nodeName)data.profile=parseEffectProfileCOMMON(child)}library.effects[xml.getAttribute("id")]=data})),parseLibrary(collada,"library_materials","material",(function(xml){const data={name:xml.getAttribute("name")};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"instance_effect"===child.nodeName)data.url=parseId(child.getAttribute("url"))}library.materials[xml.getAttribute("id")]=data})),parseLibrary(collada,"library_cameras","camera",(function(xml){const data={name:xml.getAttribute("name")};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"optics"===child.nodeName)data.optics=parseCameraOptics(child)}library.cameras[xml.getAttribute("id")]=data})),parseLibrary(collada,"library_lights","light",(function(xml){let data={};for(let i=0,l=xml.childNodes.length;i<l;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"technique_common"===child.nodeName)data=parseLightTechnique(child)}library.lights[xml.getAttribute("id")]=data})),parseLibrary(collada,"library_geometries","geometry",(function(xml){const data={name:xml.getAttribute("name"),sources:{},vertices:{},primitives:[]},mesh=getElementsByTagName(xml,"mesh")[0];if(void 0!==mesh){for(let i=0;i<mesh.childNodes.length;i++){const child=mesh.childNodes[i];if(1!==child.nodeType)continue;const id=child.getAttribute("id");switch(child.nodeName){case"source":data.sources[id]=parseSource(child);break;case"vertices":data.vertices=parseGeometryVertices(child);break;case"polygons":console.warn("THREE.ColladaLoader: Unsupported primitive type: ",child.nodeName);break;case"lines":case"linestrips":case"polylist":case"triangles":data.primitives.push(parseGeometryPrimitive(child));break;default:console.log(child)}}library.geometries[xml.getAttribute("id")]=data}})),parseLibrary(collada,"library_nodes","node",parseNode),parseLibrary(collada,"library_visual_scenes","visual_scene",(function(xml){const data={name:xml.getAttribute("name"),children:[]};!function(xml){const elements=xml.getElementsByTagName("node");for(let i=0;i<elements.length;i++){const element=elements[i];!1===element.hasAttribute("id")&&element.setAttribute("id","three_default_"+count++)}}(xml);const elements=getElementsByTagName(xml,"node");for(let i=0;i<elements.length;i++)data.children.push(parseNode(elements[i]));library.visualScenes[xml.getAttribute("id")]=data})),parseLibrary(collada,"library_kinematics_models","kinematics_model",(function(xml){const data={name:xml.getAttribute("name")||"",joints:{},links:[]};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"technique_common"===child.nodeName)parseKinematicsTechniqueCommon(child,data)}library.kinematicsModels[xml.getAttribute("id")]=data})),parseLibrary(collada,"library_physics_models","physics_model",(function(xml){const data={name:xml.getAttribute("name")||"",rigidBodies:{}};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"rigid_body"===child.nodeName)data.rigidBodies[child.getAttribute("name")]={},parsePhysicsRigidBody(child,data.rigidBodies[child.getAttribute("name")])}library.physicsModels[xml.getAttribute("id")]=data})),parseLibrary(collada,"scene","instance_kinematics_scene",(function(xml){const data={bindJointAxis:[]};for(let i=0;i<xml.childNodes.length;i++){const child=xml.childNodes[i];if(1===child.nodeType&&"bind_joint_axis"===child.nodeName)data.bindJointAxis.push(parseKinematicsBindJointAxis(child))}library.kinematicsScenes[parseId(xml.getAttribute("url"))]=data})),buildLibrary(library.animations,buildAnimation),buildLibrary(library.clips,buildAnimationClip),buildLibrary(library.controllers,buildController),buildLibrary(library.images,buildImage),buildLibrary(library.effects,buildEffect),buildLibrary(library.materials,buildMaterial),buildLibrary(library.cameras,buildCamera),buildLibrary(library.lights,buildLight),buildLibrary(library.geometries,buildGeometry),buildLibrary(library.visualScenes,buildVisualScene),function(){const clips=library.clips;if(!0===isEmpty(clips)){if(!1===isEmpty(library.animations)){const tracks=[];for(const id in library.animations){const animationTracks=getAnimation(id);for(let i=0,l=animationTracks.length;i<l;i++)tracks.push(animationTracks[i])}animations.push(new _three.AnimationClip("default",-1,tracks))}}else for(const id in clips)animations.push(getAnimationClip(id))}(),function(){const kinematicsModelId=Object.keys(library.kinematicsModels)[0],kinematicsSceneId=Object.keys(library.kinematicsScenes)[0],visualSceneId=Object.keys(library.visualScenes)[0];if(void 0===kinematicsModelId||void 0===kinematicsSceneId)return;const kinematicsModel=(id=kinematicsModelId,getBuild(library.kinematicsModels[id],buildKinematicsModel));var id;const kinematicsScene=function(id){return getBuild(library.kinematicsScenes[id],buildKinematicsScene)}(kinematicsSceneId),visualScene=getVisualScene(visualSceneId),bindJointAxis=kinematicsScene.bindJointAxis,jointMap={};for(let i=0,l=bindJointAxis.length;i<l;i++){const axis=bindJointAxis[i],targetElement=collada.querySelector('[sid="'+axis.target+'"]');if(targetElement){const parentVisualElement=targetElement.parentElement;connect(axis.jointIndex,parentVisualElement)}}function connect(jointIndex,visualElement){const visualElementName=visualElement.getAttribute("name"),joint=kinematicsModel.joints[jointIndex];visualScene.traverse((function(object){object.name===visualElementName&&(jointMap[jointIndex]={object:object,transforms:buildTransformList(visualElement),joint:joint,position:joint.zeroPosition})}))}const m0=new _three.Matrix4;kinematics={joints:kinematicsModel&&kinematicsModel.joints,getJointValue:function(jointIndex){const jointData=jointMap[jointIndex];if(jointData)return jointData.position;console.warn("THREE.ColladaLoader: Joint "+jointIndex+" doesn't exist.")},setJointValue:function(jointIndex,value){const jointData=jointMap[jointIndex];if(jointData){const joint=jointData.joint;if(value>joint.limits.max||value<joint.limits.min)console.warn("THREE.ColladaLoader: Joint "+jointIndex+" value "+value+" outside of limits (min: "+joint.limits.min+", max: "+joint.limits.max+").");else if(joint.static)console.warn("THREE.ColladaLoader: Joint "+jointIndex+" is static.");else{const object=jointData.object,axis=joint.axis,transforms=jointData.transforms;matrix.identity();for(let i=0;i<transforms.length;i++){const transform=transforms[i];if(transform.sid&&-1!==transform.sid.indexOf(jointIndex))switch(joint.type){case"revolute":matrix.multiply(m0.makeRotationAxis(axis,_three.MathUtils.degToRad(value)));break;case"prismatic":matrix.multiply(m0.makeTranslation(axis.x*value,axis.y*value,axis.z*value));break;default:console.warn("THREE.ColladaLoader: Unknown joint type: "+joint.type)}else switch(transform.type){case"matrix":matrix.multiply(transform.obj);break;case"translate":matrix.multiply(m0.makeTranslation(transform.obj.x,transform.obj.y,transform.obj.z));break;case"scale":matrix.scale(transform.obj);break;case"rotate":matrix.multiply(m0.makeRotationAxis(transform.obj,transform.angle))}}object.matrix.copy(matrix),object.matrix.decompose(object.position,object.quaternion,object.scale),jointMap[jointIndex].position=value}}else console.log("THREE.ColladaLoader: "+jointIndex+" does not exist.")}}}();const scene=function(xml){return getVisualScene(parseId(getElementsByTagName(xml,"instance_visual_scene")[0].getAttribute("url")))}(getElementsByTagName(collada,"scene")[0]);return scene.animations=animations,"Z_UP"===asset.upAxis&&scene.quaternion.setFromEuler(new _three.Euler(-Math.PI/2,0,0)),scene.scale.multiplyScalar(asset.unit),{get animations(){return console.warn("THREE.ColladaLoader: Please access animations over scene.animations now."),animations},kinematics:kinematics,library:library,scene:scene}}}_exports.ColladaLoader=ColladaLoader}));

//# sourceMappingURL=ColladaLoader.min.js.map