define("mod_wavefront/OBJLoader",["exports","mod_wavefront/three"],(function(_exports,_three){Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.OBJLoader=void 0;const _object_pattern=/^[og]\s*(.+)?/,_material_library_pattern=/^mtllib /,_material_use_pattern=/^usemtl /,_map_use_pattern=/^usemap /,_vA=new _three.Vector3,_vB=new _three.Vector3,_vC=new _three.Vector3,_ab=new _three.Vector3,_cb=new _three.Vector3;function ParserState(){const state={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(name,fromDeclaration){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=name,void(this.object.fromDeclaration=!1!==fromDeclaration);const previousMaterial=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:name||"",fromDeclaration:!1!==fromDeclaration,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(name,libraries){const previous=this._finalize(!1);previous&&(previous.inherited||previous.groupCount<=0)&&this.materials.splice(previous.index,1);const material={index:this.materials.length,name:name||"",mtllib:Array.isArray(libraries)&&libraries.length>0?libraries[libraries.length-1]:"",smooth:void 0!==previous?previous.smooth:this.smooth,groupStart:void 0!==previous?previous.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(index){const cloned={index:"number"==typeof index?index:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return cloned.clone=this.clone.bind(cloned),cloned}};return this.materials.push(material),material},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(end){const lastMultiMaterial=this.currentMaterial();if(lastMultiMaterial&&-1===lastMultiMaterial.groupEnd&&(lastMultiMaterial.groupEnd=this.geometry.vertices.length/3,lastMultiMaterial.groupCount=lastMultiMaterial.groupEnd-lastMultiMaterial.groupStart,lastMultiMaterial.inherited=!1),end&&this.materials.length>1)for(let mi=this.materials.length-1;mi>=0;mi--)this.materials[mi].groupCount<=0&&this.materials.splice(mi,1);return end&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),lastMultiMaterial}},previousMaterial&&previousMaterial.name&&"function"==typeof previousMaterial.clone){const declared=previousMaterial.clone(0);declared.inherited=!0,this.object.materials.push(declared)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(value,len){const index=parseInt(value,10);return 3*(index>=0?index-1:index+len/3)},parseNormalIndex:function(value,len){const index=parseInt(value,10);return 3*(index>=0?index-1:index+len/3)},parseUVIndex:function(value,len){const index=parseInt(value,10);return 2*(index>=0?index-1:index+len/2)},addVertex:function(a,b,c){const src=this.vertices,dst=this.object.geometry.vertices;dst.push(src[a+0],src[a+1],src[a+2]),dst.push(src[b+0],src[b+1],src[b+2]),dst.push(src[c+0],src[c+1],src[c+2])},addVertexPoint:function(a){const src=this.vertices;this.object.geometry.vertices.push(src[a+0],src[a+1],src[a+2])},addVertexLine:function(a){const src=this.vertices;this.object.geometry.vertices.push(src[a+0],src[a+1],src[a+2])},addNormal:function(a,b,c){const src=this.normals,dst=this.object.geometry.normals;dst.push(src[a+0],src[a+1],src[a+2]),dst.push(src[b+0],src[b+1],src[b+2]),dst.push(src[c+0],src[c+1],src[c+2])},addFaceNormal:function(a,b,c){const src=this.vertices,dst=this.object.geometry.normals;_vA.fromArray(src,a),_vB.fromArray(src,b),_vC.fromArray(src,c),_cb.subVectors(_vC,_vB),_ab.subVectors(_vA,_vB),_cb.cross(_ab),_cb.normalize(),dst.push(_cb.x,_cb.y,_cb.z),dst.push(_cb.x,_cb.y,_cb.z),dst.push(_cb.x,_cb.y,_cb.z)},addColor:function(a,b,c){const src=this.colors,dst=this.object.geometry.colors;void 0!==src[a]&&dst.push(src[a+0],src[a+1],src[a+2]),void 0!==src[b]&&dst.push(src[b+0],src[b+1],src[b+2]),void 0!==src[c]&&dst.push(src[c+0],src[c+1],src[c+2])},addUV:function(a,b,c){const src=this.uvs,dst=this.object.geometry.uvs;dst.push(src[a+0],src[a+1]),dst.push(src[b+0],src[b+1]),dst.push(src[c+0],src[c+1])},addDefaultUV:function(){const dst=this.object.geometry.uvs;dst.push(0,0),dst.push(0,0),dst.push(0,0)},addUVLine:function(a){const src=this.uvs;this.object.geometry.uvs.push(src[a+0],src[a+1])},addFace:function(a,b,c,ua,ub,uc,na,nb,nc){const vLen=this.vertices.length;let ia=this.parseVertexIndex(a,vLen),ib=this.parseVertexIndex(b,vLen),ic=this.parseVertexIndex(c,vLen);if(this.addVertex(ia,ib,ic),this.addColor(ia,ib,ic),void 0!==na&&""!==na){const nLen=this.normals.length;ia=this.parseNormalIndex(na,nLen),ib=this.parseNormalIndex(nb,nLen),ic=this.parseNormalIndex(nc,nLen),this.addNormal(ia,ib,ic)}else this.addFaceNormal(ia,ib,ic);if(void 0!==ua&&""!==ua){const uvLen=this.uvs.length;ia=this.parseUVIndex(ua,uvLen),ib=this.parseUVIndex(ub,uvLen),ic=this.parseUVIndex(uc,uvLen),this.addUV(ia,ib,ic),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(vertices){this.object.geometry.type="Points";const vLen=this.vertices.length;for(let vi=0,l=vertices.length;vi<l;vi++){const index=this.parseVertexIndex(vertices[vi],vLen);this.addVertexPoint(index),this.addColor(index)}},addLineGeometry:function(vertices,uvs){this.object.geometry.type="Line";const vLen=this.vertices.length,uvLen=this.uvs.length;for(let vi=0,l=vertices.length;vi<l;vi++)this.addVertexLine(this.parseVertexIndex(vertices[vi],vLen));for(let uvi=0,l=uvs.length;uvi<l;uvi++)this.addUVLine(this.parseUVIndex(uvs[uvi],uvLen))}};return state.startObject("",!1),state}class OBJLoader extends _three.Loader{constructor(manager){super(manager),this.materials=null}load(url,onLoad,onProgress,onError){const scope=this,loader=new _three.FileLoader(this.manager);loader.setPath(this.path),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials),loader.load(url,(function(text){try{onLoad(scope.parse(text))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}}),onProgress,onError)}setMaterials(materials){return this.materials=materials,this}parse(text){const state=new ParserState;-1!==text.indexOf("\r\n")&&(text=text.replace(/\r\n/g,"\n")),-1!==text.indexOf("\\\n")&&(text=text.replace(/\\\n/g,""));const lines=text.split("\n");let line="",lineFirstChar="",lineLength=0,result=[];const trimLeft="function"==typeof"".trimLeft;for(let i=0,l=lines.length;i<l;i++)if(line=lines[i],line=trimLeft?line.trimLeft():line.trim(),lineLength=line.length,0!==lineLength&&(lineFirstChar=line.charAt(0),"#"!==lineFirstChar))if("v"===lineFirstChar){const data=line.split(/\s+/);switch(data[0]){case"v":state.vertices.push(parseFloat(data[1]),parseFloat(data[2]),parseFloat(data[3])),data.length>=7?state.colors.push(parseFloat(data[4]),parseFloat(data[5]),parseFloat(data[6])):state.colors.push(void 0,void 0,void 0);break;case"vn":state.normals.push(parseFloat(data[1]),parseFloat(data[2]),parseFloat(data[3]));break;case"vt":state.uvs.push(parseFloat(data[1]),parseFloat(data[2]))}}else if("f"===lineFirstChar){const vertexData=line.substr(1).trim().split(/\s+/),faceVertices=[];for(let j=0,jl=vertexData.length;j<jl;j++){const vertex=vertexData[j];if(vertex.length>0){const vertexParts=vertex.split("/");faceVertices.push(vertexParts)}}const v1=faceVertices[0];for(let j=1,jl=faceVertices.length-1;j<jl;j++){const v2=faceVertices[j],v3=faceVertices[j+1];state.addFace(v1[0],v2[0],v3[0],v1[1],v2[1],v3[1],v1[2],v2[2],v3[2])}}else if("l"===lineFirstChar){const lineParts=line.substring(1).trim().split(" ");let lineVertices=[];const lineUVs=[];if(-1===line.indexOf("/"))lineVertices=lineParts;else for(let li=0,llen=lineParts.length;li<llen;li++){const parts=lineParts[li].split("/");""!==parts[0]&&lineVertices.push(parts[0]),""!==parts[1]&&lineUVs.push(parts[1])}state.addLineGeometry(lineVertices,lineUVs)}else if("p"===lineFirstChar){const pointData=line.substr(1).trim().split(" ");state.addPointGeometry(pointData)}else if(null!==(result=_object_pattern.exec(line))){const name=(" "+result[0].substr(1).trim()).substr(1);state.startObject(name)}else if(_material_use_pattern.test(line))state.object.startMaterial(line.substring(7).trim(),state.materialLibraries);else if(_material_library_pattern.test(line))state.materialLibraries.push(line.substring(7).trim());else if(_map_use_pattern.test(line))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===lineFirstChar){if(result=line.split(" "),result.length>1){const value=result[1].trim().toLowerCase();state.object.smooth="0"!==value&&"off"!==value}else state.object.smooth=!0;const material=state.object.currentMaterial();material&&(material.smooth=state.object.smooth)}else{if("\0"===line)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+line+'"')}state.finalize();const container=new _three.Group;container.materialLibraries=[].concat(state.materialLibraries);if(!0===!(1===state.objects.length&&0===state.objects[0].geometry.vertices.length))for(let i=0,l=state.objects.length;i<l;i++){const object=state.objects[i],geometry=object.geometry,materials=object.materials,isLine="Line"===geometry.type,isPoints="Points"===geometry.type;let hasVertexColors=!1;if(0===geometry.vertices.length)continue;const buffergeometry=new _three.BufferGeometry;buffergeometry.setAttribute("position",new _three.Float32BufferAttribute(geometry.vertices,3)),geometry.normals.length>0&&buffergeometry.setAttribute("normal",new _three.Float32BufferAttribute(geometry.normals,3)),geometry.colors.length>0&&(hasVertexColors=!0,buffergeometry.setAttribute("color",new _three.Float32BufferAttribute(geometry.colors,3))),!0===geometry.hasUVIndices&&buffergeometry.setAttribute("uv",new _three.Float32BufferAttribute(geometry.uvs,2));const createdMaterials=[];for(let mi=0,miLen=materials.length;mi<miLen;mi++){const sourceMaterial=materials[mi],materialHash=sourceMaterial.name+"_"+sourceMaterial.smooth+"_"+hasVertexColors;let material=state.materials[materialHash];if(null!==this.materials)if(material=this.materials.create(sourceMaterial.name),!isLine||!material||material instanceof _three.LineBasicMaterial){if(isPoints&&material&&!(material instanceof _three.PointsMaterial)){const materialPoints=new _three.PointsMaterial({size:10,sizeAttenuation:!1});_three.Material.prototype.copy.call(materialPoints,material),materialPoints.color.copy(material.color),materialPoints.map=material.map,material=materialPoints}}else{const materialLine=new _three.LineBasicMaterial;_three.Material.prototype.copy.call(materialLine,material),materialLine.color.copy(material.color),material=materialLine}void 0===material&&(material=isLine?new _three.LineBasicMaterial:isPoints?new _three.PointsMaterial({size:1,sizeAttenuation:!1}):new _three.MeshPhongMaterial,material.name=sourceMaterial.name,material.flatShading=!sourceMaterial.smooth,material.vertexColors=hasVertexColors,state.materials[materialHash]=material),createdMaterials.push(material)}let mesh;if(createdMaterials.length>1){for(let mi=0,miLen=materials.length;mi<miLen;mi++){const sourceMaterial=materials[mi];buffergeometry.addGroup(sourceMaterial.groupStart,sourceMaterial.groupCount,mi)}mesh=isLine?new _three.LineSegments(buffergeometry,createdMaterials):isPoints?new _three.Points(buffergeometry,createdMaterials):new _three.Mesh(buffergeometry,createdMaterials)}else mesh=isLine?new _three.LineSegments(buffergeometry,createdMaterials[0]):isPoints?new _three.Points(buffergeometry,createdMaterials[0]):new _three.Mesh(buffergeometry,createdMaterials[0]);mesh.name=object.name,container.add(mesh)}else if(state.vertices.length>0){const material=new _three.PointsMaterial({size:1,sizeAttenuation:!1}),buffergeometry=new _three.BufferGeometry;buffergeometry.setAttribute("position",new _three.Float32BufferAttribute(state.vertices,3)),state.colors.length>0&&void 0!==state.colors[0]&&(buffergeometry.setAttribute("color",new _three.Float32BufferAttribute(state.colors,3)),material.vertexColors=!0);const points=new _three.Points(buffergeometry,material);container.add(points)}return container}}_exports.OBJLoader=OBJLoader}));

//# sourceMappingURL=OBJLoader.min.js.map