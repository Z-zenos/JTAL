{"version":3,"file":"ColladaLoader.min.js","sources":["../src/ColladaLoader.js"],"sourcesContent":["import {\n\tAmbientLight,\n\tAnimationClip,\n\tBone,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDirectionalLight,\n\tDoubleSide,\n\tEuler,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tGroup,\n\tLine,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tLoaderUtils,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshLambertMaterial,\n\tMeshPhongMaterial,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tScene,\n\tSkeleton,\n\tSkinnedMesh,\n\tSpotLight,\n\tTextureLoader,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'mod_wavefront/three';\n\nimport { TGALoader } from 'mod_wavefront/TGALoader';\n\nclass ColladaLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, path ) {\n\n\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tconst array = [];\n\t\t\tconst childNodes = xml.childNodes;\n\n\t\t\tfor ( let i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\tarray.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseStrings( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseFloats( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseInts( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseId( text ) {\n\n\t\t\treturn text.substring( 1 );\n\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t}\n\n\t\tfunction isEmpty( object ) {\n\n\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset( xml ) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\tconst library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\tif ( library !== undefined ) {\n\n\t\t\t\tconst elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild( data, builder ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\tdata.build = builder( data );\n\n\t\t\treturn data.build;\n\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tlet hasChildren = false;\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet id;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\t// hierarchy of related animations\n\t\t\t\t\t\tparseAnimation( child );\n\t\t\t\t\t\thasChildren = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasChildren === false ) {\n\n\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) || MathUtils.generateUUID() ] = data;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tconst target = xml.getAttribute( 'target' );\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tlet parts = target.split( '/' );\n\n\t\t\tconst id = parts.shift();\n\t\t\tlet sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tconst arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tconst memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\n\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tconst indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildAnimation( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst channels = data.channels;\n\t\t\tconst samplers = data.samplers;\n\t\t\tconst sources = data.sources;\n\n\t\t\tfor ( const target in channels ) {\n\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\tconst channel = channels[ target ];\n\t\t\t\t\tconst sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\tconst inputId = sampler.inputs.INPUT;\n\t\t\t\t\tconst outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tconst inputSource = sources[ inputId ];\n\t\t\t\t\tconst outputSource = sources[ outputId ];\n\n\t\t\t\t\tconst animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction getAnimation( id ) {\n\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t}\n\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\tconst node = library.nodes[ channel.id ];\n\t\t\tconst object3D = getNode( node.id );\n\n\t\t\tconst transform = node.transforms[ channel.sid ];\n\t\t\tconst defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tlet time, stride;\n\t\t\tlet i, il, j, jl;\n\n\t\t\tconst data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch ( transform ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\tconst value = outputSource.array[ stride ];\n\t\t\t\t\t\t\tconst index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\tconst animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\n\t\t}\n\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\tconst keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor ( const time in data ) {\n\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort( ascending );\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\treturn a.time - b.time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst position = new Vector3();\n\t\tconst scale = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\tconst keyframes = animation.keyframes;\n\t\t\tconst name = animation.name;\n\n\t\t\tconst times = [];\n\t\t\tconst positionData = [];\n\t\t\tconst quaternionData = [];\n\t\t\tconst scaleData = [];\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tconst time = keyframe.time;\n\t\t\t\tconst value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t}\n\n\t\t\tif ( positionData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\tlet keyframe;\n\n\t\t\tlet empty = true;\n\t\t\tlet i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( empty === true ) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\tlet prev, next;\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildAnimationClip( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst name = data.name;\n\t\t\tconst duration = ( data.end - data.start ) || - 1;\n\t\t\tconst animations = data.animations;\n\n\t\t\tfor ( let i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\tconst animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\tfor ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, duration, tracks );\n\n\t\t}\n\n\t\tfunction getAnimationClip( id ) {\n\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSkin( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tconst id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseJoints( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildController( data ) {\n\n\t\t\tconst build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tconst geometry = library.geometries[ build.id ];\n\n\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildSkin( data ) {\n\n\t\t\tconst BONE_LIMIT = 4;\n\n\t\t\tconst build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertexWeights = data.vertexWeights;\n\n\t\t\tconst vcount = vertexWeights.vcount;\n\t\t\tconst v = vertexWeights.v;\n\t\t\tconst jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tconst weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tconst jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\tconst inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\tconst weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\tlet stride = 0;\n\n\t\t\tlet i, j, l;\n\n\t\t\t// procces skin data for each vertex\n\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\tconst jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\tconst vertexSkinData = [];\n\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\tconst skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\tconst weightId = v[ stride + weightOffset ];\n\t\t\t\t\tconst skinWeight = weights[ weightId ];\n\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\tstride += 2;\n\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\tconst d = vertexSkinData[ j ];\n\n\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t} else {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().identity();\n\n\t\t\t}\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\tconst name = jointSource.array[ i ];\n\t\t\t\tconst boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending( a, b ) {\n\n\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getController( id ) {\n\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildImage( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data.init_from;\n\n\t\t}\n\n\t\tfunction getImage( id ) {\n\n\t\t\tconst data = library.images[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\tconst sid = xml.getAttribute( 'sid' );\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\topaque: child.hasAttribute( 'opaque' ) ? child.getAttribute( 'opaque' ) : 'A_ONE',\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechniqueBump( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), texcoord: child.getAttribute( 'texcoord' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildEffect( data ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getEffect( id ) {\n\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction getTextureLoader( image ) {\n\n\t\t\tlet loader;\n\n\t\t\tlet extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\textension = extension.toLowerCase();\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'tga':\n\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tloader = textureLoader;\n\n\t\t\t}\n\n\t\t\treturn loader;\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tconst effect = getEffect( data.url );\n\t\t\tconst technique = effect.profile.technique;\n\n\t\t\tlet material;\n\n\t\t\tswitch ( technique.type ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new MeshPhongMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new MeshLambertMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new MeshBasicMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name || '';\n\n\t\t\tfunction getTexture( textureObject ) {\n\n\t\t\t\tconst sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\tlet image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\tconst surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\tconst loader = getTextureLoader( image );\n\n\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\tconst texture = loader.load( image );\n\n\t\t\t\t\t\tconst extra = textureObject.extra;\n\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\tconst technique = extra.technique;\n\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst parameters = technique.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tconst parameter = parameters[ key ];\n\n\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet transparent = parameters[ 'transparent' ];\n\t\t\tlet transparency = parameters[ 'transparency' ];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t} };\n\n\t\t\t}\n\n\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst color = transparent.data.color;\n\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\n\t\t\tif ( technique.extra !== undefined && technique.extra.technique !== undefined ) {\n\n\t\t\t\tconst techniques = technique.extra.technique;\n\n\t\t\t\tfor ( const k in techniques ) {\n\n\t\t\t\t\tconst v = techniques[ k ];\n\n\t\t\t\t\tswitch ( k ) {\n\n\t\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\t\tmaterial.side = ( v === 1 ? DoubleSide : FrontSide );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\t\tmaterial.normalMap = getTexture( v.texture );\n\t\t\t\t\t\t\tmaterial.normalScale = new Vector2( 1, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction getMaterial( id ) {\n\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {};\n\n\t\t}\n\n\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildCamera( data ) {\n\n\t\t\tlet camera;\n\n\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new PerspectiveCamera(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tlet ymag = data.optics.parameters.ymag;\n\t\t\t\t\tlet xmag = data.optics.parameters.xmag;\n\t\t\t\t\tconst aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new OrthographicCamera(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name || '';\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tfunction getCamera( id ) {\n\n\t\t\tconst data = library.cameras[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight( xml ) {\n\n\t\t\tlet data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseLightParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new Color().fromArray( array );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tconst f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildLight( data ) {\n\n\t\t\tlet light;\n\n\t\t\tswitch ( data.technique ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new DirectionalLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new PointLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new SpotLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new AmbientLight();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\n\t\t}\n\n\t\tfunction getLight( id ) {\n\n\t\t\tconst data = library.lights[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tconst mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\n\t\t\tfor ( let i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = mesh.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tconst id = child.getAttribute( 'id' );\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSource( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tconst accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\tconst primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tconst set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\tconst inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn primitive;\n\n\t\t}\n\n\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\tconst build = {};\n\n\t\t\tfor ( let i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\tlet count = 0;\n\n\t\t\tfor ( let i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertices = data.vertices;\n\t\t\tconst primitives = data.primitives;\n\n\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tconst groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\tfor ( const type in groupedPrimitives ) {\n\n\t\t\t\tconst primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst position = { array: [], stride: 0 };\n\t\t\tconst normal = { array: [], stride: 0 };\n\t\t\tconst uv = { array: [], stride: 0 };\n\t\t\tconst uv2 = { array: [], stride: 0 };\n\t\t\tconst color = { array: [], stride: 0 };\n\n\t\t\tconst skinIndex = { array: [], stride: 4 };\n\t\t\tconst skinWeight = { array: [], stride: 4 };\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst materialKeys = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\tconst primitive = primitives[ p ];\n\t\t\t\tconst inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tlet count = 0;\n\n\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor ( let g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\tconst vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor ( const name in inputs ) {\n\n\t\t\t\t\tconst input = inputs[ name ];\n\n\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( const key in vertices ) {\n\n\t\t\t\t\t\t\t\tconst id = vertices[ key ];\n\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tconst prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n\t\t\t\t\t\t\tuv2.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) );\n\t\t\tif ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new Float32BufferAttribute( uv2.array, uv2.stride ) );\n\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryData( primitive, source, offset, array ) {\n\n\t\t\tconst indices = primitive.p;\n\t\t\tconst stride = primitive.stride;\n\t\t\tconst vcount = primitive.vcount;\n\n\t\t\tfunction pushVector( i ) {\n\n\t\t\t\tlet index = indices[ i + offset ] * sourceStride;\n\t\t\t\tconst length = index + sourceStride;\n\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst sourceArray = source.array;\n\t\t\tconst sourceStride = source.stride;\n\n\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\tlet index = 0;\n\n\t\t\t\tfor ( let i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst count = vcount[ i ];\n\n\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\t\t\t\t\t\tconst d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\tfor ( let k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\t\tconst b = index + stride * k;\n\t\t\t\t\t\t\tconst c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\tpushVector( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getGeometry( id ) {\n\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsModel( id ) {\n\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\tlet data;\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new Vector3(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tconst max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\tconst min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\tdata.static = true;\n\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tconst array = parseFloats( xml.textContent );\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new Matrix4();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// physics\n\n\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\trigidBodies: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scene\n\n\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tconst tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsScene( id ) {\n\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tconst kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\tconst kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\tconst visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\tconst kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tconst kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tconst visualScene = getVisualScene( visualSceneId );\n\n\t\t\tconst bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tconst jointMap = {};\n\n\t\t\tfor ( let i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\tconst axis = bindJointAxis[ i ];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tconst targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t// get the parent of the transform element\n\n\t\t\t\t\tconst parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\tconst visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tconst joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst m0 = new Matrix4();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\tconst joint = jointData.joint;\n\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst object = jointData.object;\n\t\t\t\t\t\t\tconst axis = joint.axis;\n\t\t\t\t\t\t\tconst transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, MathUtils.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction buildTransformList( node ) {\n\n\t\t\tconst transforms = [];\n\n\t\t\tconst xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array, vector;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst matrix = new Matrix4().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transforms;\n\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes( xml ) {\n\n\t\t\tconst elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tconst element = elements[ i ];\n\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst matrix = new Matrix4();\n\t\tconst vector = new Vector3();\n\n\t\tfunction parseNode( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new Matrix4(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t} else {\n\n\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tconst instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\tfor ( let j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst instance = instances[ j ];\n\t\t\t\t\t\t\tconst symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tconst target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\tconst boneData = [];\n\t\t\tconst sortedBoneData = [];\n\n\t\t\tlet i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\tconst skeleton = skeletons[ i ];\n\n\t\t\t\tlet root;\n\n\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tconst visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\tconst children = visualScene.children;\n\n\t\t\t\t\tfor ( let j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\tconst child = children[ j ];\n\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\tconst root = getNode( child.id );\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t}\n\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\tlet boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor ( let i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\tconst joint = joints[ i ];\n\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction buildNode( data ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tconst matrix = data.matrix;\n\t\t\tconst nodes = data.nodes;\n\t\t\tconst type = data.type;\n\t\t\tconst instanceCameras = data.instanceCameras;\n\t\t\tconst instanceControllers = data.instanceControllers;\n\t\t\tconst instanceLights = data.instanceLights;\n\t\t\tconst instanceGeometries = data.instanceGeometries;\n\t\t\tconst instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor ( let i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor ( let i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceControllers[ i ];\n\t\t\t\tconst controller = getController( instance.id );\n\t\t\t\tconst geometries = getGeometry( controller.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tconst skeletons = instance.skeletons;\n\t\t\t\tconst joints = controller.skin.joints;\n\n\t\t\t\tconst skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst object = newObjects[ j ];\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor ( let i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor ( let i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceGeometries[ i ];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tconst geometries = getGeometry( instance.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor ( let i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tlet object;\n\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tobject = ( type === 'JOINT' ) ? new Bone() : new Group();\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tconst fallbackMaterial = new MeshBasicMaterial( { color: 0xff00ff } );\n\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\tconst materials = [];\n\n\t\t\tfor ( let i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\tconst id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tfor ( const type in geometries ) {\n\n\t\t\t\tconst geometry = geometries[ type ];\n\n\t\t\t\tconst materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\tmaterials.push( new LineBasicMaterial() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( new MeshPhongMaterial() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tconst skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tconst material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tlet object;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new LineSegments( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new Line( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry.data, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry.data, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push( object );\n\n\t\t\t}\n\n\t\t\treturn objects;\n\n\t\t}\n\n\t\tfunction hasNode( id ) {\n\n\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getNode( id ) {\n\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes( xml );\n\n\t\t\tconst elements = getElementsByTagName( xml, 'node' );\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildVisualScene( data ) {\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.name = data.name;\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction hasVisualScene( id ) {\n\n\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getVisualScene( id ) {\n\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene( xml ) {\n\n\t\t\tconst instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tconst clips = library.clips;\n\n\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tconst tracks = [];\n\n\t\t\t\t\tfor ( const id in library.animations ) {\n\n\t\t\t\t\t\tconst animationTracks = getAnimation( id );\n\n\t\t\t\t\t\tfor ( let i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push( new AnimationClip( 'default', - 1, tracks ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( const id in clips ) {\n\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the parser error element into text with each child elements text\n\t\t// separated by new lines.\n\n\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\tlet result = '';\n\t\t\tconst stack = [ parserError ];\n\n\t\t\twhile ( stack.length ) {\n\n\t\t\t\tconst node = stack.shift();\n\n\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result.trim();\n\n\t\t}\n\n\t\tif ( text.length === 0 ) {\n\n\t\t\treturn { scene: new Scene() };\n\n\t\t}\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\tconst collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\tconst parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\tif ( parserError !== undefined ) {\n\n\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\tconst errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\tlet errorText;\n\n\t\t\tif ( errorElement ) {\n\n\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t} else {\n\n\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t}\n\n\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// metadata\n\n\t\tconst version = collada.getAttribute( 'version' );\n\t\tconsole.log( 'THREE.ColladaLoader: File version', version );\n\n\t\tconst asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\tconst textureLoader = new TextureLoader( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\tlet tgaLoader;\n\n\t\tif ( TGALoader ) {\n\n\t\t\ttgaLoader = new TGALoader( this.manager );\n\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t}\n\n\t\t//\n\n\t\tconst animations = [];\n\t\tlet kinematics = {};\n\t\tlet count = 0;\n\n\t\t//\n\n\t\tconst library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tphysicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tconst scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\t\tscene.animations = animations;\n\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\tscene.quaternion.setFromEuler( new Euler( - Math.PI / 2, 0, 0 ) );\n\n\t\t}\n\n\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\treturn {\n\t\t\tget animations() {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );\n\t\t\t\treturn animations;\n\n\t\t\t},\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\n\t}\n\n}\n\nexport { ColladaLoader };\n"],"names":["ColladaLoader","Loader","constructor","manager","load","url","onLoad","onProgress","onError","scope","this","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","isEmpty","object","Object","keys","parseAssetUnit","undefined","hasAttribute","getAttribute","parseAssetUpAxis","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimationSampler","inputs","nodeType","id","semantic","parseAnimationChannel","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","channels","samplers","sources","target","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","createKeyframeTracks","buildAnimationChannel","getAnimation","animations","inputSource","outputSource","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","value","index","warn","keyframes","sort","ascending","transformAnimationData","a","b","prepareAnimationData","uuid","position","Vector3","scale","quaternion","Quaternion","animation","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","VectorKeyframeTrack","QuaternionKeyframeTrack","property","defaultValue","empty","prev","next","getPrev","getNext","interpolate","createMissingKeyframes","key","buildAnimationClip","duration","end","start","animationTracks","AnimationClip","getAnimationClip","clips","parseSkin","bindShapeMatrix","parseSource","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","skin","BONE_LIMIT","weights","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","skinWeight","weight","descending","d","bindMatrix","Matrix4","identity","boneInverse","buildSkin","skinIndices","skinWeights","buildImage","init_from","getImage","images","parseEffectProfileCOMMON","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","buildMaterial","effect","effects","profile","material","MeshPhongMaterial","MeshLambertMaterial","MeshBasicMaterial","getTexture","textureObject","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","getTextureLoader","texture","wrapS","wrapU","RepeatWrapping","ClampToEdgeWrapping","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","techniques","k","side","DoubleSide","FrontSide","normalScale","Vector2","getMaterial","materials","parseCameraOptics","parseCameraTechnique","parseCameraParameters","buildCamera","camera","optics","PerspectiveCamera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","OrthographicCamera","getCamera","cameras","parseLightTechnique","parseLightParameters","Color","falloffAngle","f","distance","Math","sqrt","buildLight","light","DirectionalLight","PointLight","SpotLight","AmbientLight","copy","getLight","lights","accessor","parseGeometryVertices","parseGeometryPrimitive","primitive","count","hasUV","inputname","max","p","checkUVCoordinates","primitives","uvsNeedsFix","buildGeometry","vertices","groupedPrimitives","groupPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","BufferGeometry","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","Float32BufferAttribute","pushVector","sourceStride","sourceArray","c","kl","getGeometry","buildKinematicsModel","parseKinematicsTechniqueCommon","parseKinematicsJoint","links","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","MathUtils","degToRad","parsePhysicsRigidBody","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsBindJointAxis","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","buildTransformList","collada","querySelector","vector","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","multiply","makeTranslation","makeRotationAxis","log","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","visualScenes","children","bone","processed","bones","boneInverses","Skeleton","traverse","isBone","buildNode","objects","instanceCamera","controller","controllers","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","Bone","Group","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","LineBasicMaterial","skinning","attributes","LineSegments","Line","SkinnedMesh","Mesh","buildVisualScene","group","getVisualScene","scene","Scene","DOMParser","parseFromString","parserError","errorElement","errorText","result","stack","Node","TEXT_NODE","apply","parserErrorToText","version","asset","unit","upAxis","parseAsset","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","TGALoader","kinematics","kinematicsModels","physicsModels","kinematicsScenes","parseAnimation","hasChildren","generateUUID","mesh","element","prepareNodes","rigidBodies","bindJointAxis","setupAnimations","kinematicsModelId","kinematicsSceneId","visualSceneId","kinematicsModel","kinematicsScene","getKinematicsScene","visualScene","jointMap","targetElement","parentVisualElement","parentElement","connect","visualElement","visualElementName","m0","getJointValue","jointData","setJointValue","setupKinematics","parseScene","setFromEuler","Euler","PI","multiplyScalar"],"mappings":"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"}